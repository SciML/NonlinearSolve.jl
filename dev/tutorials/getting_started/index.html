<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started with Nonlinear Rootfinding in Julia · NonlinearSolve.jl</title><meta name="title" content="Getting Started with Nonlinear Rootfinding in Julia · NonlinearSolve.jl"/><meta property="og:title" content="Getting Started with Nonlinear Rootfinding in Julia · NonlinearSolve.jl"/><meta property="twitter:title" content="Getting Started with Nonlinear Rootfinding in Julia · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/getting_started/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/getting_started/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/getting_started/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li class="is-active"><a class="tocitem" href>Getting Started with Nonlinear Rootfinding in Julia</a><ul class="internal"><li><a class="tocitem" href="#The-Four-Types-of-Nonlinear-Systems"><span>The Four Types of Nonlinear Systems</span></a></li><li><a class="tocitem" href="#Problem-Type-1:-Solving-Nonlinear-Systems-of-Equations"><span>Problem Type 1: Solving Nonlinear Systems of Equations</span></a></li><li><a class="tocitem" href="#Problem-Type-2:-Solving-Interval-Rootfinding-Problems-with-Bracketing-Methods"><span>Problem Type 2: Solving Interval Rootfinding Problems with Bracketing Methods</span></a></li><li><a class="tocitem" href="#Problem-Type-3:-Solving-Steady-State-Problems"><span>Problem Type 3: Solving Steady State Problems</span></a></li><li><a class="tocitem" href="#Problem-Type-4:-Solving-Nonlinear-Least-Squares-Problems"><span>Problem Type 4: Solving Nonlinear Least Squares Problems</span></a></li><li><a class="tocitem" href="#Going-Beyond-the-Basics:-How-to-use-the-Documentation"><span>Going Beyond the Basics: How to use the Documentation</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li><li><a class="tocitem" href="../nonlinear_solve_gpus/">Accelerated Rootfinding on GPUs</a></li><li><a class="tocitem" href="../snes_ex2/">PETSc SNES Example 2</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li><a class="tocitem" href="../../native/solvers/">NonlinearSolve.jl Solvers</a></li><li><a class="tocitem" href="../../native/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/bracketingnonlinearsolve/">BracketingNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../native/descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../../native/globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../../native/diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/petsc/">PETSc.jl</a></li><li><a class="tocitem" href="../../api/scipy/">SciPy</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/homotopycontinuation/">HomotopyContinuation.jl</a></li></ul></li><li><span class="tocitem">Sub-Packages</span><ul><li><a class="tocitem" href="../../api/SciMLJacobianOperators/">SciMLJacobianOperators.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started with Nonlinear Rootfinding in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started with Nonlinear Rootfinding in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/tutorials/getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started-with-Nonlinear-Rootfinding-in-Julia"><a class="docs-heading-anchor" href="#Getting-Started-with-Nonlinear-Rootfinding-in-Julia">Getting Started with Nonlinear Rootfinding in Julia</a><a id="Getting-Started-with-Nonlinear-Rootfinding-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started-with-Nonlinear-Rootfinding-in-Julia" title="Permalink"></a></h1><p>NonlinearSolve.jl is a system for solving rootfinding problems, i.e. finding the value <span>$u$</span> such that <span>$f(u) = 0$</span>. In this tutorial we will go through the basics of NonlinearSolve.jl, demonstrating the core ideas and leading you to understanding the deeper parts of the documentation.</p><h2 id="The-Four-Types-of-Nonlinear-Systems"><a class="docs-heading-anchor" href="#The-Four-Types-of-Nonlinear-Systems">The Four Types of Nonlinear Systems</a><a id="The-Four-Types-of-Nonlinear-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#The-Four-Types-of-Nonlinear-Systems" title="Permalink"></a></h2><p>There are four types of nonlinear systems:</p><ol><li>The &quot;standard nonlinear system&quot;, i.e. the <code>NonlinearProblem</code>. This is a system of equations with an initial condition where you want to satisfy all equations simultaneously.</li><li>The &quot;interval rootfinding problem&quot;, i.e. the <code>IntervalNonlinearProblem</code>. This is the case where you&#39;re given an interval <code>[a,b]</code> and need to find where <code>f(u) = 0</code> for <code>u</code> inside the bounds.</li><li>The &quot;steady state problem&quot;, i.e. find the <code>u</code> such that <code>u&#39; = f(u) = 0</code>. While related to (1), it&#39;s not entirely the same because there&#39;s a uniquely defined privileged root.</li><li>The nonlinear least squares problem, which is an under/over-constrained nonlinear system which might not be satisfiable, i.e. there may be no <code>u</code> such that <code>f(u) = 0</code>, and thus we find the <code>u</code> which minimizes <code>||f(u)||</code> in the least squares sense.</li></ol><p>One important distinction is that (1) and (3) require the input and output sizes to be the same, while (4) does not.</p><h2 id="Problem-Type-1:-Solving-Nonlinear-Systems-of-Equations"><a class="docs-heading-anchor" href="#Problem-Type-1:-Solving-Nonlinear-Systems-of-Equations">Problem Type 1: Solving Nonlinear Systems of Equations</a><a id="Problem-Type-1:-Solving-Nonlinear-Systems-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Type-1:-Solving-Nonlinear-Systems-of-Equations" title="Permalink"></a></h2><p>A nonlinear system <span>$f(u) = 0$</span> is specified by defining a function <code>f(u,p)</code>, where <code>p</code> are the parameters of the system. For example, the following solves the vector equation <span>$f(u) = u^2 - p$</span> for a vector of equations:</p><pre><code class="language-julia hljs">import NonlinearSolve as NLS

f(u, p) = u .* u .- p
u0 = [1.0, 1.0]
p = 2.0
prob = NLS.NonlinearProblem(f, u0, p)
sol = NLS.solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>where <code>u0</code> is the initial condition for the rootfinder. Native NonlinearSolve.jl solvers use the given type of <code>u0</code> to determine the type used within the solver and the return. Note that the parameters <code>p</code> can be any type, but most are an AbstractArray for automatic differentiation.</p><h3 id="Investigating-the-Solution"><a class="docs-heading-anchor" href="#Investigating-the-Solution">Investigating the Solution</a><a id="Investigating-the-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Investigating-the-Solution" title="Permalink"></a></h3><p>To investigate the solution, one can look at the elements of the <code>NonlinearSolution</code>. The most important value is <code>sol.u</code>: this is the <code>u</code> that satisfies <code>f(u) = 0</code>. For example:</p><pre><code class="language-julia hljs">u = sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><pre><code class="language-julia hljs">f(u, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 4.440892098500626e-16
 4.440892098500626e-16</code></pre><p>This final value, the difference of the solution against zero, can also be found with <code>sol.resid</code>:</p><pre><code class="language-julia hljs">sol.resid</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 4.440892098500626e-16
 4.440892098500626e-16</code></pre><p>To know if the solution converged, or why the solution had not converged we can check the return code (<code>retcode</code>):</p><pre><code class="language-julia hljs">sol.retcode</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReturnCode.Success = 1</code></pre><p>There are multiple return codes which can mean the solve was successful, and thus we can use the general command <code>SciMLBase.successful_retcode</code> to check whether the solution process exited as intended:</p><pre><code class="language-julia hljs">import SciMLBase
SciMLBase.successful_retcode(sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If we&#39;re curious about what it took to solve this equation, then you&#39;re in luck because all of the details can be found in <code>sol.stats</code>:</p><pre><code class="language-julia hljs">sol.stats</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SciMLBase.NLStats
Number of function evaluations:                    7
Number of Jacobians created:                       6
Number of factorizations:                          0
Number of linear solves:                           5
Number of nonlinear solver iterations:             5</code></pre><p>For more information on <code>NonlinearSolution</code>s, see the <a href="../../basics/nonlinear_solution/#solution"><code>NonlinearSolution</code> manual page</a>.</p><h3 id="Interacting-with-the-Solver-Options"><a class="docs-heading-anchor" href="#Interacting-with-the-Solver-Options">Interacting with the Solver Options</a><a id="Interacting-with-the-Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-the-Solver-Options" title="Permalink"></a></h3><p>While <code>sol = NonlinearSolve.solve(prob)</code> worked for our case here, in many situations you may need to interact more deeply with how the solving process is done. First things first, you can specify the solver using the positional arguments. For example, let&#39;s set the solver to <code>TrustRegion()</code>:</p><pre><code class="language-julia hljs">NLS.solve(prob, NLS.TrustRegion())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>For a complete list of solver choices, see <a href="../../solvers/nonlinear_system_solvers/#nonlinearsystemsolvers">the nonlinear system solvers page</a>.</p><p>Next we can modify the tolerances. Here let&#39;s set some really low tolerances to force a tight solution:</p><pre><code class="language-julia hljs">NLS.solve(prob, NLS.TrustRegion(), reltol = 1e-12, abstol = 1e-12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>There are many more options for doing this configuring. Specifically for handling termination conditions, see the <a href="../../basics/termination_condition/#termination_condition">Termination Conditions</a> page for more details. And for more details on all of the available keyword arguments, see the <a href="../../basics/solve/#solver_options">solver options</a> page.</p><h2 id="Problem-Type-2:-Solving-Interval-Rootfinding-Problems-with-Bracketing-Methods"><a class="docs-heading-anchor" href="#Problem-Type-2:-Solving-Interval-Rootfinding-Problems-with-Bracketing-Methods">Problem Type 2: Solving Interval Rootfinding Problems with Bracketing Methods</a><a id="Problem-Type-2:-Solving-Interval-Rootfinding-Problems-with-Bracketing-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Type-2:-Solving-Interval-Rootfinding-Problems-with-Bracketing-Methods" title="Permalink"></a></h2><p>For scalar rootfinding problems, bracketing methods exist in NonlinearSolve. The difference with bracketing methods is that with bracketing methods, instead of giving a <code>u0</code> initial condition, you pass a <code>uspan (a,b)</code> bracket in which the zero is expected to live. For example:</p><pre><code class="language-julia hljs">import NonlinearSolve as NLS
f(u, p) = u * u - 2.0
uspan = (1.0, 2.0) # brackets
prob_int = NLS.IntervalNonlinearProblem(f, uspan)
sol = NLS.solve(prob_int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 1.4142135623730951</code></pre><p>All of the same option handling from before works just as before, now just with different solver choices (see the <a href="../../solvers/bracketing_solvers/#bracketing">bracketing solvers</a> page for more details). For example, let&#39;s set the solver to <code>ITP()</code> and set a high absolute tolerance:</p><pre><code class="language-julia hljs">sol = NLS.solve(prob_int, NLS.ITP(), abstol = 0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 1.4142151754357926</code></pre><h2 id="Problem-Type-3:-Solving-Steady-State-Problems"><a class="docs-heading-anchor" href="#Problem-Type-3:-Solving-Steady-State-Problems">Problem Type 3: Solving Steady State Problems</a><a id="Problem-Type-3:-Solving-Steady-State-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Type-3:-Solving-Steady-State-Problems" title="Permalink"></a></h2><p>For Steady State Problems, we have a wrapper package <a href="https://github.com/SciML/SteadyStateDiffEq.jl">SteadyStateDiffEq.jl</a>. This package automates handling SteadyStateProblems with NonlinearSolve and OrdinaryDiffEq.</p><pre><code class="language-julia hljs">import NonlinearSolve as NLS
import SteadyStateDiffEq as SSDE

f(u, p, t) = [2 - 2u[1]; u[1] - 4u[2]]
u0 = [0.0, 0.0]
prob = SSDE.SteadyStateProblem(f, u0)

NLS.solve(prob, SSDE.SSRootfind())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.0
 0.25</code></pre><p>If you don&#39;t provide a nonlinear solver to <code>SSRootfind</code> it uses a polyalgorithm from NonlinearSolve. We can also provide the actual nonlinear solver to use:</p><pre><code class="language-julia hljs">NLS.solve(prob, SSDE.SSRootfind(NLS.Broyden()))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.0
 0.2500000000000001</code></pre><h2 id="Problem-Type-4:-Solving-Nonlinear-Least-Squares-Problems"><a class="docs-heading-anchor" href="#Problem-Type-4:-Solving-Nonlinear-Least-Squares-Problems">Problem Type 4: Solving Nonlinear Least Squares Problems</a><a id="Problem-Type-4:-Solving-Nonlinear-Least-Squares-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Type-4:-Solving-Nonlinear-Least-Squares-Problems" title="Permalink"></a></h2><pre><code class="language-julia hljs">import NonlinearSolve as NLS

function nlls!(du, u, p)
    du[1] = 2u[1] - 2
    du[2] = u[1] - 4u[2]
    du[3] = 0
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">nlls! (generic function with 1 method)</code></pre><p>Note that here the output array is of length <code>3</code> while the input array is of length <code>2</code>. We need to provide the <code>resid_prototype</code> to tell the solver what the output size is (this can be skipped for out of place problems):</p><pre><code class="language-julia hljs">u0 = [0.0, 0.0]
prob = NLS.NonlinearLeastSquaresProblem(
    NLS.NonlinearFunction(nlls!, resid_prototype = zeros(3)), u0)

NLS.solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 0.9999999999999998
 0.25</code></pre><p>Same as before, we can change the solver and tolerances:</p><pre><code class="language-julia hljs">NLS.solve(prob, NLS.GaussNewton(), reltol = 1e-12, abstol = 1e-12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 0.9999999999999998
 0.25</code></pre><h2 id="Going-Beyond-the-Basics:-How-to-use-the-Documentation"><a class="docs-heading-anchor" href="#Going-Beyond-the-Basics:-How-to-use-the-Documentation">Going Beyond the Basics: How to use the Documentation</a><a id="Going-Beyond-the-Basics:-How-to-use-the-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Going-Beyond-the-Basics:-How-to-use-the-Documentation" title="Permalink"></a></h2><p>Congrats, you now know how to use the basics of NonlinearSolve.jl! However, there is so much more to see. Next check out:</p><ul><li><a href="../code_optimization/#code_optimization">Some code optimization tricks to know about with NonlinearSolve.jl</a></li><li><a href="../iterator_interface/#iterator">An iterator interface which lets you step through the solving process step by step</a></li><li><a href="../large_systems/#large_systems">How to handle large systems of equations efficiently</a></li><li><a href="../small_compile/#fast_startup">Ways to use NonlinearSolve.jl that is faster to startup and can statically compile</a></li><li><a href="../../basics/termination_condition/#termination_condition">More detailed termination conditions</a></li></ul><p>And also check out the rest of the manual.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a><a class="docs-footer-nextpage" href="../code_optimization/">Code Optimization for Small Nonlinear Systems in Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 6 September 2025 13:06">Saturday 6 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

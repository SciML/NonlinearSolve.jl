<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl</title><meta name="title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="og:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="twitter:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Code Optimization for Small Nonlinear Systems in Julia</a><ul class="internal"><li><a class="tocitem" href="#General-Code-Optimization-in-Julia"><span>General Code Optimization in Julia</span></a></li><li><a class="tocitem" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><span>Optimizing Nonlinear Solver Code for Small Systems</span></a></li><li><a class="tocitem" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><span>Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</span></a></li></ul></li><li><a class="tocitem" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li><li><a class="tocitem" href="../nonlinear_solve_gpus/">Accelerated Rootfinding on GPUs</a></li><li><a class="tocitem" href="../snes_ex2/">PETSc SNES Example 2</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li><a class="tocitem" href="../../native/solvers/">NonlinearSolve.jl Solvers</a></li><li><a class="tocitem" href="../../native/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/bracketingnonlinearsolve/">BracketingNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../native/descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../../native/globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../../native/diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/petsc/">PETSc.jl</a></li><li><a class="tocitem" href="../../api/scipy/">SciPy</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/homotopycontinuation/">HomotopyContinuation.jl</a></li></ul></li><li><span class="tocitem">Sub-Packages</span><ul><li><a class="tocitem" href="../../api/SciMLJacobianOperators/">SciMLJacobianOperators.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/tutorials/code_optimization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="code_optimization"><a class="docs-heading-anchor" href="#code_optimization">Code Optimization for Small Nonlinear Systems in Julia</a><a id="code_optimization-1"></a><a class="docs-heading-anchor-permalink" href="#code_optimization" title="Permalink"></a></h1><h2 id="General-Code-Optimization-in-Julia"><a class="docs-heading-anchor" href="#General-Code-Optimization-in-Julia">General Code Optimization in Julia</a><a id="General-Code-Optimization-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#General-Code-Optimization-in-Julia" title="Permalink"></a></h2><p>Before starting this tutorial, we recommend the reader to check out one of the many tutorials for optimization Julia code. The following is an incomplete list:</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/performance-tips/">The Julia Performance Tips</a></li><li><a href="https://mitmath.github.io/18337/lecture2/optimizing">MIT 18.337 Course Notes on Optimizing Serial Code</a></li><li><a href="https://viralinstruction.com/posts/hardware/">What scientists must know about hardware to write fast code</a></li></ul><p>User-side optimizations are important because, for sufficiently difficult problems, most time will be spent inside your <code>f</code> function, the function you are trying to solve. “Efficient solvers&quot; are those that reduce the required number of <code>f</code> calls to hit the error tolerance. The main ideas for optimizing your nonlinear solver code, or any Julia function, are the following:</p><ul><li>Make it non-allocating</li><li>Use StaticArrays for small arrays</li><li>Use broadcast fusion</li><li>Make it type-stable</li><li>Reduce redundant calculations</li><li>Make use of BLAS calls</li><li>Optimize algorithm choice</li></ul><p>We&#39;ll discuss these strategies in the context of nonlinear solvers. Let&#39;s start with small systems.</p><h2 id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><a class="docs-heading-anchor" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems">Optimizing Nonlinear Solver Code for Small Systems</a><a id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems" title="Permalink"></a></h2><p>Take for example a prototypical small nonlinear solver code in its out-of-place form:</p><pre><code class="language-julia hljs">import NonlinearSolve as NLS

f(u, p) = u .* u .- p
u0 = [1.0, 1.0]
p = 2.0
prob = NLS.NonlinearProblem(f, u0, p)
sol = NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>We can use BenchmarkTools.jl to get more precise timings:</p><pre><code class="language-julia hljs">import BenchmarkTools

BenchmarkTools.@benchmark NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">14.036 μs</span></span> … <span class="sgr35">186.410 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">14.988 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">15.351 μs</span></span> ± <span class="sgr32">  3.775 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▃▇█<span class="sgr34">▇</span>▃<span class="sgr32">▁</span>                                                      
  ▃▆███<span class="sgr34">█</span>█<span class="sgr32">█</span>▇▅▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂ ▃
  14 μs<span class="sgr90">           Histogram: frequency by time</span>         25.1 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">6.09 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">67</span>.</code></pre><p>Note that this way of writing the function is a shorthand for:</p><pre><code class="language-julia hljs">f(u, p) = [u[1] * u[1] - p, u[2] * u[2] - p]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>where the function <code>f</code> returns an array. This is a common pattern from things like MATLAB&#39;s <code>fzero</code> or SciPy&#39;s <code>scipy.optimize.fsolve</code>. However, by design it&#39;s very slow. In the benchmark you can see that there are many allocations. These allocations cause the memory allocator to take more time than the actual numerics itself, which is one of the reasons why codes from MATLAB and Python end up slow.</p><p>In order to avoid this issue, we can use a non-allocating &quot;in-place&quot; approach. Written out by hand, this looks like:</p><pre><code class="language-julia hljs">function f(du, u, p)
    du[1] = u[1] * u[1] - p
    du[2] = u[2] * u[2] - p
    return nothing
end

prob = NLS.NonlinearProblem(f, u0, p)
BenchmarkTools.@benchmark sol = NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">11.552 μs</span></span> … <span class="sgr35">78.648 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">12.263 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">12.614 μs</span></span> ± <span class="sgr32"> 1.628 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▅█<span class="sgr34">▇</span>▁<span class="sgr32"> </span>                                                      
  ▃▇██<span class="sgr34">█</span>█<span class="sgr32">▆</span>▄▃▃▂▂▂▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▁▁▂▁▁▁▂▂▁▁▂▂▂▂▂▂ ▃
  11.6 μs<span class="sgr90">         Histogram: frequency by time</span>        21.7 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">4.58 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">50</span>.</code></pre><p>Notice how much faster this already runs! We can make this code even simpler by using the <code>.=</code> in-place broadcasting.</p><pre><code class="language-julia hljs">function f(du, u, p)
    du .= u .* u .- p
    return nothing
end

BenchmarkTools.@benchmark sol = NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">11.642 μs</span></span> … <span class="sgr35">103.214 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">12.313 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">12.534 μs</span></span> ± <span class="sgr32">  1.611 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▆█<span class="sgr34">▇</span><span class="sgr32">▃</span>                                                        
  ▂▇██<span class="sgr34">█</span><span class="sgr32">█</span>▆▅▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▂▂▁▁▁▂▁▁▁▁▁▁▁▁▂▁▁▂▂▂▂▂▁▂▂▂ ▃
  11.6 μs<span class="sgr90">         Histogram: frequency by time</span>         21.7 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">4.58 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">50</span>.</code></pre><h2 id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><a class="docs-heading-anchor" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve">Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</a><a id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve" title="Permalink"></a></h2><p>Allocations are only expensive if they are “heap allocations”. For a more in-depth definition of heap allocations, <a href="https://net-informations.com/faq/net/stack-heap.htm">there are many sources online</a>. But a good working definition is that heap allocations are variable-sized slabs of memory which have to be pointed to, and this pointer indirection costs time. Additionally, the heap has to be managed, and the garbage controllers has to actively keep track of what&#39;s on the heap.</p><p>However, there&#39;s an alternative to heap allocations, known as stack allocations. The stack is statically-sized (known at compile time) and thus its accesses are quick. Additionally, the exact block of memory is known in advance by the compiler, and thus re-using the memory is cheap. This means that allocating on the stack has essentially no cost!</p><p>Arrays have to be heap allocated because their size (and thus the amount of memory they take up) is determined at runtime. But there are structures in Julia which are stack-allocated. <code>struct</code>s for example are stack-allocated “value-type”s. <code>Tuple</code>s are a stack-allocated collection. The most useful data structure for NonlinearSolve though is the <code>StaticArray</code> from the package <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. These arrays have their length determined at compile-time. They are created using macros attached to normal array expressions, for example:</p><pre><code class="language-julia hljs">import StaticArrays

A = StaticArrays.SA[2.0, 3.0, 5.0]
typeof(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SVector{3, Float64}<span class="sgr90"> (alias for StaticArraysCore.SArray{Tuple{3}, Float64, 1, 3})</span></code></pre><p>Notice that the <code>3</code> after <code>SVector</code> gives the size of the <code>SVector</code>. It cannot be changed. Additionally, <code>SVector</code>s are immutable, so we have to create a new <code>SVector</code> to change values. But remember, we don&#39;t have to worry about allocations because this data structure is stack-allocated. <code>SArray</code>s have numerous extra optimizations as well: they have fast matrix multiplication, fast QR factorizations, etc. which directly make use of the information about the size of the array. Thus, when possible, they should be used.</p><p>Unfortunately, static arrays can only be used for sufficiently small arrays. After a certain size, they are forced to heap allocate after some instructions and their compile time balloons. Thus, static arrays shouldn&#39;t be used if your system has more than ~20 variables. Additionally, only the native Julia algorithms can fully utilize static arrays.</p><p>Let&#39;s ***optimize our nonlinear solve using static arrays***. Note that in this case, we want to use the out-of-place allocating form, but this time we want to output a static array. Doing it with broadcasting looks like:</p><pre><code class="language-julia hljs">f_SA(u, p) = u .* u .- p

u0 = StaticArrays.SA[1.0, 1.0]
p = 2.0
prob = NLS.NonlinearProblem(f_SA, u0, p)

BenchmarkTools.@benchmark NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 7 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">4.058 μs</span></span> … <span class="sgr35">724.781 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 98.38%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">4.337 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">4.593 μs</span></span> ± <span class="sgr32">  7.219 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>1.55% ±  0.98%

      ▃▇█▅<span class="sgr34">▂</span>       <span class="sgr32"> </span>                                            
  ▁▂▃▆████<span class="sgr34">█</span>▇▄▄▄▄▃▃<span class="sgr32">▂</span>▂▂▃▃▃▃▂▂▂▂▃▃▂▂▂▂▂▂▂▁▁▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  4.06 μs<span class="sgr90">         Histogram: frequency by time</span>        6.09 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">2.31 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">16</span>.</code></pre><p>Note that only change here is that <code>u0</code> is made into a StaticArray! If we needed to write <code>f</code> out for a more complex nonlinear case, then we&#39;d simply do the following:</p><pre><code class="language-julia hljs">f_SA(u, p) = StaticArrays.SA[u[1] * u[1] - p, u[2] * u[2] - p]

BenchmarkTools.@benchmark NLS.solve(prob, NLS.NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 8 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">3.166 μs</span></span> … <span class="sgr35">634.340 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 98.42%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">3.443 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">3.744 μs</span></span> ± <span class="sgr32">  8.839 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.30% ±  1.39%

       ▅██▅<span class="sgr34">▂</span>        <span class="sgr32"> </span>                                          
  ▁▁▂▄▇████<span class="sgr34">█</span>▆▄▃▃▂▂▂▂<span class="sgr32">▂</span>▃▃▃▂▂▂▂▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  3.17 μs<span class="sgr90">         Histogram: frequency by time</span>        5.03 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">2.31 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">16</span>.</code></pre><p>However, notice that this did not give us a speedup but rather a slowdown. This is because many of the methods in NonlinearSolve.jl are designed to scale to larger problems, and thus aggressively do things like caching which is good for large problems but not good for these smaller problems and static arrays. In order to see the full benefit, we need to move to one of the methods from SimpleNonlinearSolve.jl which are designed for these small-scale static examples. Let&#39;s now use <code>SimpleNewtonRaphson</code>:</p><pre><code class="language-julia hljs">BenchmarkTools.@benchmark NLS.solve(prob, NLS.SimpleNewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 58 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">868.517 ns</span></span> … <span class="sgr35"> 1.443 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">872.845 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">883.581 ns</span></span> ± <span class="sgr32">34.595 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▆█<span class="sgr34">▆</span>▆▅▃<span class="sgr32">▂</span>▁▁▁                                           ▂▂▁▁    ▂
  ██<span class="sgr34">█</span>███<span class="sgr32">█</span>████▇▇██▇▇▇▇▇▇▆▆▆▆▅▅▆▅▆▄▆▅▅▄▄▅▄▄▅▅▅▄▄▅▅▃▅▄▁▁▆██████▇▆ █
  869 ns<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      1.02 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">80 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1</span>.</code></pre><p>And there we go, around <code>40ns</code> from our starting point of almost <code>4μs</code>!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started with Nonlinear Rootfinding in Julia</a><a class="docs-footer-nextpage" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 04:43">Monday 4 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

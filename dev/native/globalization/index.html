<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Globalization Subroutines · NonlinearSolve.jl</title><meta name="title" content="Globalization Subroutines · NonlinearSolve.jl"/><meta property="og:title" content="Globalization Subroutines · NonlinearSolve.jl"/><meta property="twitter:title" content="Globalization Subroutines · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/globalization/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/globalization/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/native/globalization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li><a class="tocitem" href="../solvers/">NonlinearSolve.jl Solvers</a></li><li><a class="tocitem" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../descent/">Descent Subroutines</a></li><li class="is-active"><a class="tocitem" href>Globalization Subroutines</a><ul class="internal"><li><a class="tocitem" href="#line-search"><span>Line Search Algorithms</span></a></li><li><a class="tocitem" href="#Radius-Update-Schemes-for-Trust-Region"><span>Radius Update Schemes for Trust Region</span></a></li></ul></li><li><a class="tocitem" href="../diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Native Functionalities</a></li><li class="is-active"><a href>Globalization Subroutines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Globalization Subroutines</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/native/globalization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Globalization-Subroutines"><a class="docs-heading-anchor" href="#Globalization-Subroutines">Globalization Subroutines</a><a id="Globalization-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Globalization-Subroutines" title="Permalink"></a></h1><p>The following globalization subroutines are available.</p><ul><li><a href="#NonlinearSolve.RadiusUpdateSchemes"><code>NonlinearSolve.RadiusUpdateSchemes</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.Bastin"><code>NonlinearSolve.RadiusUpdateSchemes.Bastin</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.Fan"><code>NonlinearSolve.RadiusUpdateSchemes.Fan</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.Hei"><code>NonlinearSolve.RadiusUpdateSchemes.Hei</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.NLsolve"><code>NonlinearSolve.RadiusUpdateSchemes.NLsolve</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.NocedalWright"><code>NonlinearSolve.RadiusUpdateSchemes.NocedalWright</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.Simple"><code>NonlinearSolve.RadiusUpdateSchemes.Simple</code></a></li><li><a href="#NonlinearSolve.RadiusUpdateSchemes.Yuan"><code>NonlinearSolve.RadiusUpdateSchemes.Yuan</code></a></li><li><a href="#NonlinearSolve.LiFukushimaLineSearch"><code>NonlinearSolve.LiFukushimaLineSearch</code></a></li><li><a href="#NonlinearSolve.LineSearchesJL"><code>NonlinearSolve.LineSearchesJL</code></a></li><li><a href="#NonlinearSolve.NoLineSearch"><code>NonlinearSolve.NoLineSearch</code></a></li><li><a href="#NonlinearSolve.RobustNonMonotoneLineSearch"><code>NonlinearSolve.RobustNonMonotoneLineSearch</code></a></li></ul><h2 id="line-search"><a class="docs-heading-anchor" href="#line-search">Line Search Algorithms</a><a id="line-search-1"></a><a class="docs-heading-anchor-permalink" href="#line-search" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.LiFukushimaLineSearch" href="#NonlinearSolve.LiFukushimaLineSearch"><code>NonlinearSolve.LiFukushimaLineSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LiFukushimaLineSearch(; lambda_0 = 1, beta = 1 // 2, sigma_1 = 1 // 1000,
    sigma_2 = 1 // 1000, eta = 1 // 10, nan_max_iter::Int = 5, maxiters::Int = 100)</code></pre><p>A derivative-free line search and global convergence of Broyden-like method for nonlinear equations [<a href="../../references/#li2000derivative">9</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/line_search.jl#L308-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.LineSearchesJL" href="#NonlinearSolve.LineSearchesJL"><code>NonlinearSolve.LineSearchesJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineSearchesJL(; method = LineSearches.Static(), autodiff = nothing, α = true)</code></pre><p>Wrapper over algorithms from <a href="https://github.com/JuliaNLSolvers/LineSearches.jl/">LineSearches.jl</a>. Allows automatic construction of the objective functions for the line search algorithms utilizing automatic differentiation for fast Vector Jacobian Products.</p><p><strong>Arguments</strong></p><ul><li><code>method</code>: the line search algorithm to use. Defaults to <code>method = LineSearches.Static()</code>, which means that the step size is fixed to the value of <code>alpha</code>.</li><li><code>autodiff</code>: the automatic differentiation backend to use for the line search. Using a reverse mode automatic differentiation backend if recommended.</li><li><code>α</code>: the initial step size to use. Defaults to <code>true</code> (which is equivalent to <code>1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/line_search.jl#L21-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RobustNonMonotoneLineSearch" href="#NonlinearSolve.RobustNonMonotoneLineSearch"><code>NonlinearSolve.RobustNonMonotoneLineSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RobustNonMonotoneLineSearch(; gamma = 1 // 10000, sigma_0 = 1, M::Int = 10,
    tau_min = 1 // 10, tau_max = 1 // 2, n_exp::Int = 2, maxiters::Int = 100,
    η_strategy = (fn₁, n, uₙ, fₙ) -&gt; fn₁ / n^2)</code></pre><p>Robust NonMonotone Line Search is a derivative free line search method from DF Sane [<a href="../../references/#la2006spectral">2</a>].</p><p><strong>Keyword Arguments</strong></p><ul><li><code>M</code>: The monotonicity of the algorithm is determined by a this positive integer. A value of 1 for <code>M</code> would result in strict monotonicity in the decrease of the L2-norm of the function <code>f</code>. However, higher values allow for more flexibility in this reduction. Despite this, the algorithm still ensures global convergence through the use of a non-monotone line-search algorithm that adheres to the Grippo-Lampariello-Lucidi condition. Values in the range of 5 to 20 are usually sufficient, but some cases may call for a higher value of <code>M</code>. The default setting is 10.</li><li><code>gamma</code>: a parameter that influences if a proposed step will be accepted. Higher value of <code>gamma</code> will make the algorithm more restrictive in accepting steps. Defaults to <code>1e-4</code>.</li><li><code>tau_min</code>: if a step is rejected the new step size will get multiplied by factor, and this parameter is the minimum value of that factor. Defaults to <code>0.1</code>.</li><li><code>tau_max</code>: if a step is rejected the new step size will get multiplied by factor, and this parameter is the maximum value of that factor. Defaults to <code>0.5</code>.</li><li><code>n_exp</code>: the exponent of the loss, i.e. <span>$f_n=||F(x_n)||^{n\_exp}$</span>. The paper uses <code>n_exp ∈ {1, 2}</code>. Defaults to <code>2</code>.</li><li><code>η_strategy</code>:  function to determine the parameter <code>η</code>, which enables growth of <span>$||f_n||^2$</span>. Called as <code>η = η_strategy(fn_1, n, x_n, f_n)</code> with <code>fn_1</code> initialized as <span>$fn_1=||f(x_1)||^{n\_exp}$</span>, <code>n</code> is the iteration number, <code>x_n</code> is the current <code>x</code>-value and <code>f_n</code> the current residual. Should satisfy <span>$η &gt; 0$</span> and <span>$∑ₖ ηₖ &lt; ∞$</span>. Defaults to <span>$fn_1 / n^2$</span>.</li><li><code>maxiters</code>: the maximum number of iterations allowed for the inner loop of the algorithm. Defaults to <code>100</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/line_search.jl#L186-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.NoLineSearch" href="#NonlinearSolve.NoLineSearch"><code>NonlinearSolve.NoLineSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoLineSearch &lt;: AbstractNonlinearSolveLineSearchAlgorithm</code></pre><p>Don&#39;t perform a line search. Just return the initial step length of <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/line_search.jl#L1-L5">source</a></section></article><h2 id="Radius-Update-Schemes-for-Trust-Region"><a class="docs-heading-anchor" href="#Radius-Update-Schemes-for-Trust-Region">Radius Update Schemes for Trust Region</a><a id="Radius-Update-Schemes-for-Trust-Region-1"></a><a class="docs-heading-anchor-permalink" href="#Radius-Update-Schemes-for-Trust-Region" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes" href="#NonlinearSolve.RadiusUpdateSchemes"><code>NonlinearSolve.RadiusUpdateSchemes</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes</code></pre><p><code>RadiusUpdateSchemes</code> is provides different types of radius update schemes implemented in the Trust Region method. These schemes specify how the radius of the so-called trust region is updated after each iteration of the algorithm. The specific role and caveats associated with each scheme are provided below.</p><p><strong>Using <code>RadiusUpdateSchemes</code></strong></p><p>Simply put the desired scheme as follows: <code>sol = solve(prob, alg = TrustRegion(radius_update_scheme = RadiusUpdateSchemes.Hei))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L94-L106">source</a></section></article><h3 id="Available-Radius-Update-Schemes"><a class="docs-heading-anchor" href="#Available-Radius-Update-Schemes">Available Radius Update Schemes</a><a id="Available-Radius-Update-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Radius-Update-Schemes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Simple" href="#NonlinearSolve.RadiusUpdateSchemes.Simple"><code>NonlinearSolve.RadiusUpdateSchemes.Simple</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.Simple</code></pre><p>The simple or conventional radius update scheme. This scheme is chosen by default and follows the conventional approach to update the trust region radius, i.e. if the trial step is accepted it increases the radius by a fixed factor (bounded by a maximum radius) and if the trial step is rejected, it shrinks the radius by a fixed factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Hei" href="#NonlinearSolve.RadiusUpdateSchemes.Hei"><code>NonlinearSolve.RadiusUpdateSchemes.Hei</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.Hei</code></pre><p>This scheme is proposed in <a href="../../references/#hei2003self">Hei [10]</a>. The trust region radius depends on the size (norm) of the current step size. The hypothesis is to let the radius converge to zero as the iterations progress, which is more reliable and robust for ill-conditioned as well as degenerate problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Yuan" href="#NonlinearSolve.RadiusUpdateSchemes.Yuan"><code>NonlinearSolve.RadiusUpdateSchemes.Yuan</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.Yuan</code></pre><p>This scheme is proposed by <a href="../../references/#yuan2015recent">Yuan [6]</a>. Similar to Hei&#39;s scheme, the trust region is updated in a way so that it converges to zero, however here, the radius depends on the size (norm) of the current gradient of the objective (merit) function. The hypothesis is that the step size is bounded by the gradient size, so it makes sense to let the radius depend on the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Bastin" href="#NonlinearSolve.RadiusUpdateSchemes.Bastin"><code>NonlinearSolve.RadiusUpdateSchemes.Bastin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.Bastin</code></pre><p>This scheme is proposed by <a href="../../references/#bastin2010retrospective">Bastin <em>et al.</em> [11]</a>. The scheme is called a retrospective update scheme as it uses the model function at the current iteration to compute the ratio of the actual reduction and the predicted reduction in the previous trial step, and use this ratio to update the trust region radius. The hypothesis is to exploit the information made available during the optimization process in order to vary the accuracy of the objective function computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Fan" href="#NonlinearSolve.RadiusUpdateSchemes.Fan"><code>NonlinearSolve.RadiusUpdateSchemes.Fan</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.Fan</code></pre><p>This scheme is proposed by <a href="../../references/#fan2006convergence">Fan [12]</a>. It is very much similar to Hei&#39;s and Yuan&#39;s schemes as it lets the trust region radius depend on the current size (norm) of the objective (merit) function itself. These new update schemes are known to improve local convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.NLsolve" href="#NonlinearSolve.RadiusUpdateSchemes.NLsolve"><code>NonlinearSolve.RadiusUpdateSchemes.NLsolve</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.NLsolve</code></pre><p>The same updating scheme as in NLsolve&#39;s (https://github.com/JuliaNLSolvers/NLsolve.jl) trust region dogleg implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.NocedalWright" href="#NonlinearSolve.RadiusUpdateSchemes.NocedalWright"><code>NonlinearSolve.RadiusUpdateSchemes.NocedalWright</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">RadiusUpdateSchemes.NocedalWright</code></pre><p>Trust region updating scheme as in Nocedal and Wright [see Alg 11.5, page 291].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/f3b2e1febced69ed3d0fbe1b09258620515c99be/src/globalization/trust_region.jl#L139-L143">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../descent/">« Descent Subroutines</a><a class="docs-footer-nextpage" href="../diagnostics/">Diagnostics API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 13 June 2024 22:32">Thursday 13 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NonlinearSolve.jl Solvers · NonlinearSolve.jl</title><meta name="title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta property="og:title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta property="twitter:title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li><li><a class="tocitem" href="../../tutorials/nonlinear_solve_gpus/">Accelerated Rootfinding on GPUs</a></li><li><a class="tocitem" href="../../tutorials/snes_ex2/">PETSc SNES Example 2</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/verbosity/">Controlling Solver Verbosity</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li class="is-active"><a class="tocitem" href>NonlinearSolve.jl Solvers</a><ul class="internal"><li><a class="tocitem" href="#General-Keyword-Arguments"><span>General Keyword Arguments</span></a></li><li><a class="tocitem" href="#Nonlinear-Solvers"><span>Nonlinear Solvers</span></a></li><li><a class="tocitem" href="#Nonlinear-Least-Squares-Solvers"><span>Nonlinear Least Squares Solvers</span></a></li><li><a class="tocitem" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers"><span>Both Nonlinear &amp; Nonlinear Least Squares Solvers</span></a></li><li><a class="tocitem" href="#Polyalgorithms"><span>Polyalgorithms</span></a></li><li><a class="tocitem" href="#Advanced-Solvers"><span>Advanced Solvers</span></a></li><li><a class="tocitem" href="#forcing_strategies"><span>Forcing Term Strategies</span></a></li></ul></li><li><a class="tocitem" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../bracketingnonlinearsolve/">BracketingNonlinearSolve.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/petsc/">PETSc.jl</a></li><li><a class="tocitem" href="../../api/scipy/">SciPy</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/homotopycontinuation/">HomotopyContinuation.jl</a></li></ul></li><li><span class="tocitem">Sub-Packages</span><ul><li><a class="tocitem" href="../../api/SciMLJacobianOperators/">SciMLJacobianOperators.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Native Functionalities</a></li><li class="is-active"><a href>NonlinearSolve.jl Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NonlinearSolve.jl Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/native/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="NonlinearSolve.jl-Solvers"><a class="docs-heading-anchor" href="#NonlinearSolve.jl-Solvers">NonlinearSolve.jl Solvers</a><a id="NonlinearSolve.jl-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl-Solvers" title="Permalink"></a></h1><p>These are the native solvers of NonlinearSolve.jl.</p><ul><li><a href="#NonlinearSolveBase.NonlinearSolvePolyAlgorithm"><code>NonlinearSolveBase.NonlinearSolvePolyAlgorithm</code></a></li><li><a href="#NonlinearSolveFirstOrder.EisenstatWalkerForcing2"><code>NonlinearSolveFirstOrder.EisenstatWalkerForcing2</code></a></li><li><a href="#NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm"><code>NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm</code></a></li><li><a href="#NonlinearSolveQuasiNewton.QuasiNewtonAlgorithm"><code>NonlinearSolveQuasiNewton.QuasiNewtonAlgorithm</code></a></li><li><a href="#NonlinearSolveSpectralMethods.GeneralizedDFSane"><code>NonlinearSolveSpectralMethods.GeneralizedDFSane</code></a></li><li><a href="#NonlinearSolve.FastShortcutNLLSPolyalg"><code>NonlinearSolve.FastShortcutNLLSPolyalg</code></a></li><li><a href="#NonlinearSolve.FastShortcutNonlinearPolyalg"><code>NonlinearSolve.FastShortcutNonlinearPolyalg</code></a></li><li><a href="#NonlinearSolveFirstOrder.GaussNewton"><code>NonlinearSolveFirstOrder.GaussNewton</code></a></li><li><a href="#NonlinearSolveFirstOrder.LevenbergMarquardt"><code>NonlinearSolveFirstOrder.LevenbergMarquardt</code></a></li><li><a href="#NonlinearSolveFirstOrder.NewtonRaphson"><code>NonlinearSolveFirstOrder.NewtonRaphson</code></a></li><li><a href="#NonlinearSolveFirstOrder.PseudoTransient"><code>NonlinearSolveFirstOrder.PseudoTransient</code></a></li><li><a href="#NonlinearSolveFirstOrder.RobustMultiNewton"><code>NonlinearSolveFirstOrder.RobustMultiNewton</code></a></li><li><a href="#NonlinearSolveFirstOrder.TrustRegion"><code>NonlinearSolveFirstOrder.TrustRegion</code></a></li><li><a href="#NonlinearSolveQuasiNewton.Broyden"><code>NonlinearSolveQuasiNewton.Broyden</code></a></li><li><a href="#NonlinearSolveQuasiNewton.Klement"><code>NonlinearSolveQuasiNewton.Klement</code></a></li><li><a href="#NonlinearSolveQuasiNewton.LimitedMemoryBroyden"><code>NonlinearSolveQuasiNewton.LimitedMemoryBroyden</code></a></li><li><a href="#NonlinearSolveSpectralMethods.DFSane"><code>NonlinearSolveSpectralMethods.DFSane</code></a></li></ul><h2 id="General-Keyword-Arguments"><a class="docs-heading-anchor" href="#General-Keyword-Arguments">General Keyword Arguments</a><a id="General-Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#General-Keyword-Arguments" title="Permalink"></a></h2><p>Several Algorithms share the same specification for common keyword arguments. Those are documented in this section to avoid repetition. Certain algorithms might have additional considerations for these keyword arguments, which are documented in the algorithm&#39;s documentation.</p><ul><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> solvers used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>linesearch</code>: the line search algorithm to use. Defaults to <a href="https://docs.sciml.ai/LineSearch/dev/api/native/#LineSearch.NoLineSearch"><code>NoLineSearch()</code></a>, which means that no line search is performed.</li><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification! Valid choices are types from ADTypes.jl.</li><li><code>vjp_autodiff</code>: similar to <code>autodiff</code>, but is used to compute Jacobian Vector Products. Ignored if the NonlinearFunction contains the <code>jvp</code> function.</li><li><code>vjp_autodiff</code>: similar to <code>autodiff</code>, but is used to compute Vector Jacobian Products. Ignored if the NonlinearFunction contains the <code>vjp</code> function.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-Vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>forcing</code>: Adaptive forcing term strategy for Newton-Krylov methods. When using an iterative linear solver (Krylov method), this controls how accurately the linear system is solved at each Newton iteration. Defaults to <code>nothing</code> (fixed tolerance). See <a href="#forcing_strategies">Forcing Term Strategies</a> for available options.</li></ul><h2 id="Nonlinear-Solvers"><a class="docs-heading-anchor" href="#Nonlinear-Solvers">Nonlinear Solvers</a><a id="Nonlinear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Solvers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.NewtonRaphson"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.NewtonRaphson"><code>NonlinearSolveFirstOrder.NewtonRaphson</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">NewtonRaphson(;
    concrete_jac = nothing, linsolve = nothing, linesearch = missing,
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing,
    forcing = nothing,
)</code></pre><p>An advanced NewtonRaphson implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed. Defaults to <code>nothing</code>.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> solver used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice.</li><li><code>linesearch</code>: the line search algorithm to use. Defaults to <code>missing</code> (no line search).</li><li><code>vjp_autodiff</code>: backend for computing Vector-Jacobian products.</li><li><code>jvp_autodiff</code>: backend for computing Jacobian-Vector products.</li><li><code>forcing</code>: Adaptive forcing term strategy for Newton-Krylov methods. When using an iterative linear solver (e.g., <code>KrylovJL_GMRES()</code>), this controls how accurately the linear system is solved at each iteration. Use <code>EisenstatWalkerForcing2()</code> for the classical Eisenstat-Walker adaptive forcing strategy. Defaults to <code>nothing</code> (fixed tolerance from the termination condition).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/raphson.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveSpectralMethods.DFSane"><a class="docstring-binding" href="#NonlinearSolveSpectralMethods.DFSane"><code>NonlinearSolveSpectralMethods.DFSane</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DFSane(;
    sigma_min = 1 // 10^10, sigma_max = 1e10, sigma_1 = 1, M::Int = 10,
    gamma = 1 // 10^4, tau_min = 1 // 10, tau_max = 1 // 2, n_exp::Int = 2,
    max_inner_iterations::Int = 100, eta_strategy = (fn_1, n, x_n, f_n) -&gt; fn_1 / n^2
)</code></pre><p>A low-overhead and allocation-free implementation of the df-sane method for solving large-scale nonlinear systems of equations. For in depth information about all the parameters and the algorithm, see <a href="../../references/#la2006spectral">La Cruz <em>et al.</em> [2]</a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sigma_min</code>: the minimum value of the spectral coefficient <code>σ</code> which is related to the step size in the algorithm. Defaults to <code>1e-10</code>.</li><li><code>sigma_max</code>: the maximum value of the spectral coefficient <code>σₙ</code> which is related to the step size in the algorithm. Defaults to <code>1e10</code>.</li></ul><p>For other keyword arguments, see RobustNonMonotoneLineSearch in LineSearch.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveSpectralMethods/src/dfsane.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveQuasiNewton.Broyden"><a class="docstring-binding" href="#NonlinearSolveQuasiNewton.Broyden"><code>NonlinearSolveQuasiNewton.Broyden</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Broyden(;
    max_resets::Int = 100, linesearch = nothing, reset_tolerance = nothing,
    init_jacobian::Val = Val(:identity), autodiff = nothing, alpha = nothing,
    update_rule = Val(:good_broyden)
)</code></pre><p>An implementation of <code>Broyden</code>&#39;s Method [<a href="../../references/#broyden1965class">3</a>] with resetting and line search.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>100</code>.</p></li><li><p><code>reset_tolerance</code>: the tolerance for the reset check. Defaults to <code>sqrt(eps(real(eltype(u))))</code>.</p></li><li><p><code>alpha</code>: If <code>init_jacobian</code> is set to <code>Val(:identity)</code>, then the initial Jacobian inverse is set to be <code>(αI)⁻¹</code>. Defaults to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</p></li><li><p><code>init_jacobian</code>: the method to use for initializing the jacobian. Defaults to <code>Val(:identity)</code>. Choices include:</p><ul><li><code>Val(:identity)</code>: Identity Matrix.</li><li><code>Val(:true_jacobian)</code>: True Jacobian. This is a good choice for differentiable problems.</li></ul></li><li><p><code>update_rule</code>: Update Rule for the Jacobian. Choices are:</p><ul><li><code>Val(:good_broyden)</code>: Good Broyden&#39;s Update Rule</li><li><code>Val(:bad_broyden)</code>: Bad Broyden&#39;s Update Rule</li><li><code>Val(:diagonal)</code>: Only update the diagonal of the Jacobian. This algorithm may be useful for specific problems, but whether it will work may depend strongly on the problem</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveQuasiNewton/src/broyden.jl#L1-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveQuasiNewton.Klement"><a class="docstring-binding" href="#NonlinearSolveQuasiNewton.Klement"><code>NonlinearSolveQuasiNewton.Klement</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Klement(;
    max_resets = 100, linsolve = nothing, linesearch = nothing,
    alpha = nothing, init_jacobian::Val = Val(:identity),
    autodiff = nothing
)</code></pre><p>An implementation of <code>Klement</code> [<a href="../../references/#klement2014using">4</a>] with line search, preconditioning and customizable linear solves. It is recommended to use <a href="#NonlinearSolveQuasiNewton.Broyden"><code>Broyden</code></a> for most problems over this.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>100</code>.</p></li><li><p><code>alpha</code>: If <code>init_jacobian</code> is set to <code>Val(:identity)</code>, then the initial Jacobian inverse is set to be <code>αI</code>. Defaults to <code>1</code>. Can be set to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</p></li><li><p><code>init_jacobian</code>: the method to use for initializing the jacobian. Defaults to <code>Val(:identity)</code>. Choices include:</p><ul><li><code>Val(:identity)</code>: Identity Matrix.</li><li><code>Val(:true_jacobian)</code>: True Jacobian. Our tests suggest that this is not very stable. Instead using <code>Broyden</code> with <code>Val(:true_jacobian)</code> gives faster and more reliable convergence.</li><li><code>Val(:true_jacobian_diagonal)</code>: Diagonal of True Jacobian. This is a good choice for differentiable problems.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveQuasiNewton/src/klement.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveQuasiNewton.LimitedMemoryBroyden"><a class="docstring-binding" href="#NonlinearSolveQuasiNewton.LimitedMemoryBroyden"><code>NonlinearSolveQuasiNewton.LimitedMemoryBroyden</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">LimitedMemoryBroyden(;
    max_resets::Int = 3, linesearch = nothing, threshold::Val = Val(10),
    reset_tolerance = nothing, alpha = nothing
)</code></pre><p>An implementation of <code>LimitedMemoryBroyden</code> [<a href="../../references/#ziani2008autoadaptative">5</a>] with resetting and line search.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>3</code>.</li><li><code>reset_tolerance</code>: the tolerance for the reset check. Defaults to <code>sqrt(eps(real(eltype(u))))</code>.</li><li><code>threshold</code>: the number of vectors to store in the low rank approximation. Defaults to <code>Val(10)</code>.</li><li><code>alpha</code>: The initial Jacobian inverse is set to be <code>(αI)⁻¹</code>. Defaults to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveQuasiNewton/src/lbroyden.jl#L1-L19">source</a></section></details></article><h2 id="Nonlinear-Least-Squares-Solvers"><a class="docs-heading-anchor" href="#Nonlinear-Least-Squares-Solvers">Nonlinear Least Squares Solvers</a><a id="Nonlinear-Least-Squares-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Least-Squares-Solvers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.GaussNewton"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.GaussNewton"><code>NonlinearSolveFirstOrder.GaussNewton</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">GaussNewton(;
    concrete_jac = nothing, linsolve = nothing, linesearch = missing,
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing
)</code></pre><p>An advanced GaussNewton implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/gauss_newton.jl#L1-L10">source</a></section></details></article><h2 id="Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers"><a class="docs-heading-anchor" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers">Both Nonlinear &amp; Nonlinear Least Squares Solvers</a><a id="Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers" title="Permalink"></a></h2><p>These solvers can be used for both nonlinear and nonlinear least squares problems.</p><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.TrustRegion"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.TrustRegion"><code>NonlinearSolveFirstOrder.TrustRegion</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">TrustRegion(;
    concrete_jac = nothing, linsolve = nothing,
    radius_update_scheme = RadiusUpdateSchemes.Simple, max_trust_radius::Real = 0 // 1,
    initial_trust_radius::Real = 0 // 1, step_threshold::Real = 1 // 10000,
    shrink_threshold::Real = 1 // 4, expand_threshold::Real = 3 // 4,
    shrink_factor::Real = 1 // 4, expand_factor::Real = 2 // 1,
    max_shrink_times::Int = 32,
    vjp_autodiff = nothing, autodiff = nothing, jvp_autodiff = nothing,
)</code></pre><p>An advanced TrustRegion implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>radius_update_scheme</code>: the scheme used to update the trust region radius. Defaults to <code>RadiusUpdateSchemes.Simple</code>. See <a href="../globalization/#NonlinearSolveFirstOrder.RadiusUpdateSchemes"><code>RadiusUpdateSchemes</code></a> for more details. For a review on trust region radius update schemes, see <a href="../../references/#yuan2015recent">Yuan [6]</a>.</li></ul><p>For the remaining arguments, see <a href="../../devdocs/algorithm_helpers/#NonlinearSolveFirstOrder.GenericTrustRegionScheme"><code>NonlinearSolveFirstOrder.GenericTrustRegionScheme</code></a> documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/trust_region.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.LevenbergMarquardt"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.LevenbergMarquardt"><code>NonlinearSolveFirstOrder.LevenbergMarquardt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">LevenbergMarquardt(;
    linsolve = nothing,
    damping_initial::Real = 1.0, α_geodesic::Real = 0.75, disable_geodesic = Val(false),
    damping_increase_factor::Real = 2.0, damping_decrease_factor::Real = 3.0,
    finite_diff_step_geodesic = 0.1, b_uphill::Real = 1.0, min_damping_D::Real = 1e-8,
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing
)</code></pre><p>An advanced Levenberg-Marquardt implementation with the improvements suggested in <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>damping_initial</code>: the starting value for the damping factor. The damping factor is inversely proportional to the step size. The damping factor is adjusted during each iteration. Defaults to <code>1.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>damping_increase_factor</code>: the factor by which the damping is increased if a step is rejected. Defaults to <code>2.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>damping_decrease_factor</code>: the factor by which the damping is decreased if a step is accepted. Defaults to <code>3.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>min_damping_D</code>: the minimum value of the damping terms in the diagonal damping matrix <code>DᵀD</code>, where <code>DᵀD</code> is given by the largest diagonal entries of <code>JᵀJ</code> yet encountered, where <code>J</code> is the Jacobian. It is suggested by <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a> to use a minimum value of the elements in <code>DᵀD</code> to prevent the damping from being too small. Defaults to <code>1e-8</code>.</li><li><code>disable_geodesic</code>: Disables Geodesic Acceleration if set to <code>Val(true)</code>. It provides a way to trade-off robustness for speed, though in most situations Geodesic Acceleration should not be disabled.</li></ul><p>For the remaining arguments, see <a href="../descent/#NonlinearSolveBase.GeodesicAcceleration"><code>GeodesicAcceleration</code></a> and <a href="../../devdocs/algorithm_helpers/#NonlinearSolveFirstOrder.LevenbergMarquardtTrustRegion"><code>NonlinearSolveFirstOrder.LevenbergMarquardtTrustRegion</code></a> documentations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/levenberg_marquardt.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.PseudoTransient"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.PseudoTransient"><code>NonlinearSolveFirstOrder.PseudoTransient</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PseudoTransient(;
    concrete_jac = nothing, linesearch = missing, alpha_initial = 1e-3,
    linsolve = nothing,
    autodiff = nothing, jvp_autodiff = nothing, vjp_autodiff = nothing
)</code></pre><p>An implementation of PseudoTransient Method [<a href="../../references/#coffey2003pseudotransient">7</a>] that is used to solve steady state problems in an accelerated manner. It uses an adaptive time-stepping to integrate an initial value of nonlinear problem until sufficient accuracy in the desired steady-state is achieved to switch over to Newton&#39;s method and gain a rapid convergence. This implementation specifically uses &quot;switched evolution relaxation&quot; [<a href="../../references/#kelley1998convergence">8</a>] SER method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alpha_initial</code> : the initial pseudo time step. It defaults to <code>1e-3</code>. If it is small, you are going to need more iterations to converge but it can be more stable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/pseudo_transient.jl#L1-L19">source</a></section></details></article><h2 id="Polyalgorithms"><a class="docs-heading-anchor" href="#Polyalgorithms">Polyalgorithms</a><a id="Polyalgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Polyalgorithms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NonlinearSolveBase.NonlinearSolvePolyAlgorithm"><a class="docstring-binding" href="#NonlinearSolveBase.NonlinearSolvePolyAlgorithm"><code>NonlinearSolveBase.NonlinearSolvePolyAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearSolvePolyAlgorithm(algs; start_index::Int = 1)</code></pre><p>A general way to define PolyAlgorithms for <code>NonlinearProblem</code> and <code>NonlinearLeastSquaresProblem</code>. This is a container for a tuple of algorithms that will be tried in order until one succeeds. If none succeed, then the algorithm with the lowest residual is returned.</p><p><strong>Arguments</strong></p><ul><li><code>algs</code>: a tuple of algorithms to try in-order! (If this is not a Tuple, then the returned algorithm is not type-stable).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_index</code>: the index to start at. Defaults to <code>1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using NonlinearSolve

alg = NonlinearSolvePolyAlgorithm((NewtonRaphson(), Broyden()))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveBase/src/polyalg.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolve.FastShortcutNonlinearPolyalg"><a class="docstring-binding" href="#NonlinearSolve.FastShortcutNonlinearPolyalg"><code>NonlinearSolve.FastShortcutNonlinearPolyalg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FastShortcutNonlinearPolyalg(
    ::Type{T} = Float64;
    concrete_jac = nothing,
    linsolve = nothing,
    must_use_jacobian::Val = Val(false),
    prefer_simplenonlinearsolve::Val = Val(false),
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing,
    u0_len::Union{Int, Nothing} = nothing
) where {T}</code></pre><p>A polyalgorithm focused on balancing speed and robustness. It first tries less robust methods for more performance and then tries more robust techniques if the faster ones fail.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>u0_len</code>: The length of the initial guess. If this is <code>nothing</code>, then the length of the initial guess is not checked. If this is an integer and it is less than <code>25</code>, we use jacobian based methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/src/poly_algs.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolve.FastShortcutNLLSPolyalg"><a class="docstring-binding" href="#NonlinearSolve.FastShortcutNLLSPolyalg"><code>NonlinearSolve.FastShortcutNLLSPolyalg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FastShortcutNLLSPolyalg(
    ::Type{T} = Float64;
    concrete_jac = nothing,
    linsolve = nothing,
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing
)</code></pre><p>A polyalgorithm focused on balancing speed and robustness. It first tries less robust methods for more performance and then tries more robust techniques if the faster ones fail.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/src/poly_algs.jl#L94-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.RobustMultiNewton"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.RobustMultiNewton"><code>NonlinearSolveFirstOrder.RobustMultiNewton</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RobustMultiNewton(
    ::Type{T} = Float64;
    concrete_jac = nothing,
    linsolve = nothing,
    autodiff = nothing, vjp_autodiff = nothing, jvp_autodiff = nothing
)</code></pre><p>A polyalgorithm focused on robustness. It uses a mixture of Newton methods with different globalizing techniques (trust region updates, line searches, etc.) in order to find a method that is able to adequately solve the minimization problem.</p><p>Basically, if this algorithm fails, then &quot;most&quot; good ways of solving your problem fail and you may need to think about reformulating the model (either there is an issue with the model, or more precision / more stable linear solver choice is required).</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/poly_algs.jl#L1-L21">source</a></section></details></article><h2 id="Advanced-Solvers"><a class="docs-heading-anchor" href="#Advanced-Solvers">Advanced Solvers</a><a id="Advanced-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Solvers" title="Permalink"></a></h2><p>All of the previously mentioned solvers are wrappers around the following solvers. These are meant for advanced users and allow building custom solvers.</p><article><details class="docstring" open="true"><summary id="NonlinearSolveQuasiNewton.QuasiNewtonAlgorithm"><a class="docstring-binding" href="#NonlinearSolveQuasiNewton.QuasiNewtonAlgorithm"><code>NonlinearSolveQuasiNewton.QuasiNewtonAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuasiNewtonAlgorithm(;
    linesearch = missing, trustregion = missing, descent, update_rule, reinit_rule,
    initialization, max_resets::Int = typemax(Int), name::Symbol = :unknown,
    max_shrink_times::Int = typemax(Int), concrete_jac = Val(false)
)</code></pre><p>Nonlinear Solve Algorithms using an Iterative Approximation of the Jacobian. Most common examples include <a href="#NonlinearSolveQuasiNewton.Broyden"><code>Broyden</code></a>&#39;s Method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>trustregion</code>: Globalization using a Trust Region Method. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractTrustRegionMethod"><code>NonlinearSolveBase.AbstractTrustRegionMethod</code></a> interface.</li><li><code>descent</code>: The descent method to use to compute the step. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractDescentDirection"><code>NonlinearSolveBase.AbstractDescentDirection</code></a> interface.</li><li><code>max_shrink_times</code>: The maximum number of times the trust region radius can be shrunk before the algorithm terminates.</li><li><code>update_rule</code>: The update rule to use to update the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractApproximateJacobianUpdateRule"><code>NonlinearSolveBase.AbstractApproximateJacobianUpdateRule</code></a> interface.</li><li><code>reinit_rule</code>: The reinitialization rule to use to reinitialize the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractResetCondition"><code>NonlinearSolveBase.AbstractResetCondition</code></a> interface.</li><li><code>initialization</code>: The initialization method to use to initialize the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractJacobianInitialization"><code>NonlinearSolveBase.AbstractJacobianInitialization</code></a> interface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveQuasiNewton/src/solve.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm"><code>NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeneralizedFirstOrderAlgorithm(;
    descent, linesearch = missing,
    trustregion = missing, autodiff = nothing, vjp_autodiff = nothing,
    jvp_autodiff = nothing, max_shrink_times::Int = typemax(Int),
    concrete_jac = Val(false), name::Symbol = :unknown
)</code></pre><p>This is a Generalization of First-Order (uses Jacobian) Nonlinear Solve Algorithms. The most common example of this is Newton-Raphson Method.</p><p>First Order here refers to the order of differentiation, and should not be confused with the order of convergence.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>trustregion</code>: Globalization using a Trust Region Method. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractTrustRegionMethod"><code>NonlinearSolveBase.AbstractTrustRegionMethod</code></a> interface.</li><li><code>descent</code>: The descent method to use to compute the step. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolveBase.AbstractDescentDirection"><code>NonlinearSolveBase.AbstractDescentDirection</code></a> interface.</li><li><code>max_shrink_times</code>: The maximum number of times the trust region radius can be shrunk before the algorithm terminates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/solve.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NonlinearSolveSpectralMethods.GeneralizedDFSane"><a class="docstring-binding" href="#NonlinearSolveSpectralMethods.GeneralizedDFSane"><code>NonlinearSolveSpectralMethods.GeneralizedDFSane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeneralizedDFSane(; linesearch, sigma_min, sigma_max, sigma_1, name::Symbol = :unknown)</code></pre><p>A generalized version of the DF-SANE algorithm. This algorithm is a Jacobian-Free Spectral Method.</p><p><strong>Arguments</strong></p><ul><li><code>linesearch</code>: Globalization using a Line Search Method. This is not optional currently, but that restriction might be lifted in the future.</li><li><code>sigma_min</code>: The minimum spectral parameter allowed. This is used to ensure that the spectral parameter is not too small.</li><li><code>sigma_max</code>: The maximum spectral parameter allowed. This is used to ensure that the spectral parameter is not too large.</li><li><code>sigma_1</code>: The initial spectral parameter. If this is not provided, then the algorithm initializes it as <code>sigma_1 = &lt;u, u&gt; / &lt;u, f(u)&gt;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveSpectralMethods/src/solve.jl#L4-L20">source</a></section></details></article><h2 id="forcing_strategies"><a class="docs-heading-anchor" href="#forcing_strategies">Forcing Term Strategies</a><a id="forcing_strategies-1"></a><a class="docs-heading-anchor-permalink" href="#forcing_strategies" title="Permalink"></a></h2><p>Forcing term strategies control how accurately the linear system is solved at each Newton iteration when using iterative (Krylov) linear solvers. This is the key idea behind Newton-Krylov methods: instead of solving <span>$J \delta u = -f(u)$</span> exactly, we solve it only approximately with a tolerance <span>$\eta_k$</span> (the forcing term).</p><p>The <a href="../../references/#eisenstat1996choosing">Eisenstat and Walker [9]</a> paper introduced adaptive strategies for choosing <span>$\eta_k$</span> that can significantly improve convergence, especially for problems where the initial guess is far from the solution.</p><article><details class="docstring" open="true"><summary id="NonlinearSolveFirstOrder.EisenstatWalkerForcing2"><a class="docstring-binding" href="#NonlinearSolveFirstOrder.EisenstatWalkerForcing2"><code>NonlinearSolveFirstOrder.EisenstatWalkerForcing2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EisenstatWalkerForcing2(; η₀ = 0.5, ηₘₐₓ = 0.9, γ = 0.9, α = 2, safeguard = true, safeguard_threshold = 0.1)</code></pre><p>Algorithm 2 from the classical work by Eisenstat and Walker (1996) as described by formula (2.6):     ηₖ = γ * (||rₖ|| / ||rₖ₋₁||)^α</p><p>Here the variables denote:     rₖ residual at iteration k     η₀   ∈ [0,1) initial value for η     ηₘₐₓ ∈ [0,1) maximum value for η     γ    ∈ [0,1) correction factor     α    ∈ [1,2) correction exponent</p><p>Furthermore, the proposed safeguard is implemented:     ηₖ = max(ηₖ, γ<em>ηₖ₋₁^α) if γ</em>ηₖ₋₁^α &gt; safeguard_threshold to prevent ηₖ from shrinking too fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/419715a767da74bd77cd48e8b4112eea1732e522/lib/NonlinearSolveFirstOrder/src/eisenstat_walker.jl#L1-L17">source</a></section></details></article><h3 id="Example-Usage"><a class="docs-heading-anchor" href="#Example-Usage">Example Usage</a><a id="Example-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs">using NonlinearSolve, LinearSolve

# Define a large nonlinear problem
function f!(F, u, p)
    for i in 2:(length(u) - 1)
        F[i] = u[i - 1] - 2u[i] + u[i + 1] + sin(u[i])
    end
    F[1] = u[1] - 1.0
    F[end] = u[end]
end

n = 1000
u0 = zeros(n)
prob = NonlinearProblem(f!, u0)

# Use Newton-Raphson with GMRES and Eisenstat-Walker forcing
sol = solve(prob, NewtonRaphson(
    linsolve = KrylovJL_GMRES(),
    forcing = EisenstatWalkerForcing2()
))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../solvers/fixed_point_solvers/">« Fixed Point Solvers</a><a class="docs-footer-nextpage" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 19:25">Saturday 24 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

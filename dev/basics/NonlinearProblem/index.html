<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Problems · NonlinearSolve.jl</title><meta name="title" content="Nonlinear Problems · NonlinearSolve.jl"/><meta property="og:title" content="Nonlinear Problems · NonlinearSolve.jl"/><meta property="twitter:title" content="Nonlinear Problems · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li class="is-active"><a class="tocitem" href>Nonlinear Problems</a><ul class="internal"><li><a class="tocitem" href="#The-Four-Types-of-Nonlinear-Problems"><span>The Four Types of Nonlinear Problems</span></a></li><li><a class="tocitem" href="#Problem-Construction-Details"><span>Problem Construction Details</span></a></li></ul></li><li><a class="tocitem" href="../NonlinearFunctions/">NonlinearFunctions and Jacobian Types</a></li><li><a class="tocitem" href="../solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../NonlinearSolution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../TerminationCondition/">Termination Conditions</a></li><li><a class="tocitem" href="../Logging/">Logging the Solve Process</a></li><li><a class="tocitem" href="../FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/NonlinearSystemSolvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/SteadyStateSolvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/NonlinearLeastSquaresSolvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/LineSearch/">Line Search</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/nonlinearsolve/">NonlinearSolve.jl Native Solvers</a></li><li><a class="tocitem" href="../../api/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Nonlinear Problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/basics/NonlinearProblem.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="problems"><a class="docs-heading-anchor" href="#problems">Nonlinear Problems</a><a id="problems-1"></a><a class="docs-heading-anchor-permalink" href="#problems" title="Permalink"></a></h1><h2 id="The-Four-Types-of-Nonlinear-Problems"><a class="docs-heading-anchor" href="#The-Four-Types-of-Nonlinear-Problems">The Four Types of Nonlinear Problems</a><a id="The-Four-Types-of-Nonlinear-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#The-Four-Types-of-Nonlinear-Problems" title="Permalink"></a></h2><p>NonlinearSolve.jl tackles four related types of nonlinear systems:</p><ol><li>Interval rootfinding problems. I.e., find the <span>$t \in [t_0, t_f]$</span> such that <span>$f(t) = 0$</span>.</li><li>Systems of nonlinear equations, i.e., find the <span>$u$</span> such that <span>$f(u) = 0$</span>.</li><li>Steady state problems, i.e., find the <span>$u$</span> such that <span>$u&#39; = f(u,t)$</span> has reached steady state, i.e., <span>$0 = f(u, ∞)$</span>.</li><li>The nonlinear least squares problem, which is an under/over-constrained nonlinear system which might not be satisfiable, i.e. there may be no <code>u</code> such that <code>f(u) = 0</code>, and thus we find the <code>u</code> which minimizes <code>||f(u)||</code> in the least squares sense.</li></ol><p>The first is for solving scalar rootfinding problems, i.e., finding a single number, and requires that a bracketing interval is known. For a bracketing interval, one must have that the sign of <code>f(t_0)</code> is opposite the sign of <code>f(t_f)</code>, thus guaranteeing a root in the interval.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Interval rootfinding problems allow for <code>f</code> to return an array, in which case the interval rootfinding problem is interpreted as finding the first <code>t</code> such that any of the components of the array hit zero.</p></div></div><p>The second type of nonlinear system can be multidimensional, and thus no ordering nor boundaries are assumed to be known. For a system of nonlinear equations, <code>f</code> can return an array, and the solver seeks the value of <code>u</code> for which all outputs of <code>f</code> are simultaneously zero.</p><p>The last type if equivalent to a nonlinear system, but with the extra interpretation of having a potentially preferred unique root. That is, when there are multiple <code>u</code> such that <code>f(u) = 0</code>, the <code>NonlinearProblem</code> does not have a preferred solution, while for the <code>SteadyStateProblem</code> the preferred solution is the <code>u(∞)</code> that would arise from solving the ODE <code>u&#39; = f(u,t)</code>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Most solvers for <code>SteadyStateProblem</code> do not guarantee the preferred solution and instead will solve for some <code>u</code> in the set of solutions. The documentation of the nonlinear solvers will note if they return the preferred solution.</p></div></div><h2 id="Problem-Construction-Details"><a class="docs-heading-anchor" href="#Problem-Construction-Details">Problem Construction Details</a><a id="Problem-Construction-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Construction-Details" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.IntervalNonlinearProblem" href="#SciMLBase.IntervalNonlinearProblem"><code>SciMLBase.IntervalNonlinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an interval nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/</p><p><strong>Mathematical Specification of an Interval Nonlinear Problem</strong></p><p>To define a Nonlinear Problem, you simply need to give the function <span>$f$</span> which defines the nonlinear system:</p><p class="math-container">\[f(t,p) = u = 0\]</p><p>along with an interval <code>tspan</code>, <span>$t \\in [t_0,t_f]$</span>, within which the root should be found. <code>f</code> should be specified as <code>f(t,p)</code> (or in-place as <code>f(u,t,p)</code>), and <code>tspan</code> should be a <code>Tuple{T,T} where T &lt;: Number</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output value <code>u</code> is not required to be a scalar. When <code>u</code> is an <code>AbstractArray</code>, the problem is a simultaneous interval nonlinear problem where the solvers are made to give the first <code>t</code> for which any of the <code>u</code> hit zero. Currently, none of the solvers support this mode.</p></div></div><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IntervalNonlinearProblem(f::NonlinearFunction,tspan,p=NullParameters();kwargs...)
IntervalNonlinearProblem{isinplace}(f,tspan,p=NullParameters();kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the problem.</li><li><code>tspan</code>: The interval in which the root is to be found.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.9.1/src/problems/basic_problems.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.NonlinearProblem" href="#SciMLBase.NonlinearProblem"><code>SciMLBase.NonlinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/</p><p><strong>Mathematical Specification of a Nonlinear Problem</strong></p><p>To define a Nonlinear Problem, you simply need to give the function <span>$f$</span> which defines the nonlinear system:</p><p class="math-container">\[f(u,p) = 0\]</p><p>and an initial guess <span>$u₀$</span> of where <code>f(u,p)=0</code>. <code>f</code> should be specified as <code>f(u,p)</code> (or in-place as <code>f(du,u,p)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher-dimension tensors as well.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NonlinearProblem(f::NonlinearFunction,u0,p=NullParameters();kwargs...)
NonlinearProblem{isinplace}(f,u0,p=NullParameters();kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="../NonlinearFunctions/#nonlinearfunctions">NonlinearFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the problem.</li><li><code>u0</code>: The initial guess for the root.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.9.1/src/problems/basic_problems.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SteadyStateProblem" href="#SciMLBase.SteadyStateProblem"><code>SciMLBase.SteadyStateProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a steady state ODE problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/steady<em>state</em>types/</p><p><strong>Mathematical Specification of a Steady State Problem</strong></p><p>To define a Steady State Problem, you simply need to give the function <span>$f$</span> which defines the ODE:</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t)\]</p><p>and an initial guess <span>$u_0$</span> of where <code>f(u,p,t)=0</code>. <code>f</code> should be specified as <code>f(u,p,t)</code> (or in-place as <code>f(du,u,p,t)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>Note that for the steady-state to be defined, we must have that <code>f</code> is autonomous, that is <code>f</code> is independent of <code>t</code>. But the form which matches the standard ODE solver should still be used. The steady state solvers interpret the <code>f</code> by fixing <span>$t=\\infty$</span>.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SteadyStateProblem(f::ODEFunction,u0,p=NullParameters();kwargs...)
SteadyStateProblem{isinplace,specialize}(f,u0,p=NullParameters();kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred. <code>specialize</code> optionally controls the specialization level. See the <a href="https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/#Specialization-Levels">specialization levels section of the SciMLBase documentation</a> for more details. The default is <code>AutoSpecialize</code>.</p><p>Parameters are optional, and if not given, a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>Additionally, the constructor from <code>ODEProblem</code>s is provided:</p><pre><code class="language-julia hljs">SteadyStateProblem(prob::ODEProblem)</code></pre><p>Parameters are optional, and if not given, a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the ODE.</li><li><code>u0</code>: The initial guess for the steady state.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Special Solution Fields</strong></p><p>The <code>SteadyStateSolution</code> type is different from the other DiffEq solutions because it does not have temporal information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.9.1/src/problems/steady_state_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.NonlinearLeastSquaresProblem" href="#SciMLBase.NonlinearLeastSquaresProblem"><code>SciMLBase.NonlinearLeastSquaresProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a nonlinear least squares problem.</p><p><strong>Mathematical Specification of a Nonlinear Least Squares Problem</strong></p><p>To define a Nonlinear Problem, you simply need to give the function <span>$f$</span> which defines the nonlinear system:</p><p class="math-container">\[\underset{x}{\min} \| f(x, p) \|\]</p><p>and an initial guess <span>$u_0$</span> for the minimization problem. <span>$f$</span> should be specified as <span>$f(u, p)$</span> (or in-place as <span>$f(du, u, p)$</span>), and <span>$u_0$</span><code>should be an AbstractArray (or number) whose geometry matches the desired geometry of</code><code>u</code><code>. Note that we are not limited to numbers or vectors for</code><code>u_0</code><code>; one is allowed to provide</code><code>u_0</code>` as arbitrary matrices / higher-dimension tensors as well.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NonlinearLeastSquaresProblem(f::NonlinearFunction, u0, p=NullParameters(); kwargs...)
NonlinearLeastSquaresProblem{isinplace}(f, u0, p=NullParameters(); kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters.</p><p>For specifying Jacobians and mass matrices, see the <a href="../NonlinearFunctions/#nonlinearfunctions">NonlinearFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the problem.</li><li><code>u0</code>: The initial guess for the solution.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.9.1/src/problems/basic_problems.jl#L315">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/optimizing_parameterized_ode/">« Optimizing a Parameterized ODE</a><a class="docs-footer-nextpage" href="../NonlinearFunctions/">NonlinearFunctions and Jacobian Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 9 December 2023 16:50">Saturday 9 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl</title><meta name="title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="og:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="twitter:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Code Optimization for Small Nonlinear Systems in Julia</a><ul class="internal"><li><a class="tocitem" href="#General-Code-Optimization-in-Julia"><span>General Code Optimization in Julia</span></a></li><li><a class="tocitem" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><span>Optimizing Nonlinear Solver Code for Small Systems</span></a></li><li><a class="tocitem" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><span>Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</span></a></li></ul></li><li><a class="tocitem" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li><a class="tocitem" href="../../native/solvers/">NonlinearSolve.jl Solvers</a></li><li><a class="tocitem" href="../../native/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../native/descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../../native/globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../../native/diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li></ul></li><li><span class="tocitem">Sub-Packages</span><ul><li><a class="tocitem" href="../../api/SciMLJacobianOperators/">SciMLJacobianOperators.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/tutorials/code_optimization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="code_optimization"><a class="docs-heading-anchor" href="#code_optimization">Code Optimization for Small Nonlinear Systems in Julia</a><a id="code_optimization-1"></a><a class="docs-heading-anchor-permalink" href="#code_optimization" title="Permalink"></a></h1><h2 id="General-Code-Optimization-in-Julia"><a class="docs-heading-anchor" href="#General-Code-Optimization-in-Julia">General Code Optimization in Julia</a><a id="General-Code-Optimization-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#General-Code-Optimization-in-Julia" title="Permalink"></a></h2><p>Before starting this tutorial, we recommend the reader to check out one of the many tutorials for optimization Julia code. The following is an incomplete list:</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/performance-tips/">The Julia Performance Tips</a></li><li><a href="https://mitmath.github.io/18337/lecture2/optimizing">MIT 18.337 Course Notes on Optimizing Serial Code</a></li><li><a href="https://viralinstruction.com/posts/hardware/">What scientists must know about hardware to write fast code</a></li></ul><p>User-side optimizations are important because, for sufficiently difficult problems, most time will be spent inside your <code>f</code> function, the function you are trying to solve. “Efficient solvers&quot; are those that reduce the required number of <code>f</code> calls to hit the error tolerance. The main ideas for optimizing your nonlinear solver code, or any Julia function, are the following:</p><ul><li>Make it non-allocating</li><li>Use StaticArrays for small arrays</li><li>Use broadcast fusion</li><li>Make it type-stable</li><li>Reduce redundant calculations</li><li>Make use of BLAS calls</li><li>Optimize algorithm choice</li></ul><p>We&#39;ll discuss these strategies in the context of nonlinear solvers. Let&#39;s start with small systems.</p><h2 id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><a class="docs-heading-anchor" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems">Optimizing Nonlinear Solver Code for Small Systems</a><a id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems" title="Permalink"></a></h2><p>Take for example a prototypical small nonlinear solver code in its out-of-place form:</p><pre><code class="language-julia hljs">using NonlinearSolve

f(u, p) = u .* u .- p
u0 = [1.0, 1.0]
p = 2.0
prob = NonlinearProblem(f, u0, p)
sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>We can use BenchmarkTools.jl to get more precise timings:</p><pre><code class="language-julia hljs">using BenchmarkTools

@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">29.976 μs</span></span> … <span class="sgr35">139.721 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">31.459 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">32.014 μs</span></span> ± <span class="sgr32">  2.885 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

   ▂▅▇██<span class="sgr34">█</span>█▇<span class="sgr32">▆</span>▅▃▂▂▁▁                                             ▂
  ▆█████<span class="sgr34">█</span>██<span class="sgr32">█</span>████████▇▆▆▅▄▅▅▅▅▆▄▄▃▄▄▄▄▃▃▄▂▄▃▃▂▃▂▂▄▄▆▇▆▇██▇▇██▇▇ █
  30 μs<span class="sgr90">         Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>        44 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">15.89 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">240</span>.</code></pre><p>Note that this way of writing the function is a shorthand for:</p><pre><code class="language-julia hljs">f(u, p) = [u[1] * u[1] - p, u[2] * u[2] - p]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>where the function <code>f</code> returns an array. This is a common pattern from things like MATLAB&#39;s <code>fzero</code> or SciPy&#39;s <code>scipy.optimize.fsolve</code>. However, by design it&#39;s very slow. In the benchmark you can see that there are many allocations. These allocations cause the memory allocator to take more time than the actual numerics itself, which is one of the reasons why codes from MATLAB and Python end up slow.</p><p>In order to avoid this issue, we can use a non-allocating &quot;in-place&quot; approach. Written out by hand, this looks like:</p><pre><code class="language-julia hljs">function f(du, u, p)
    du[1] = u[1] * u[1] - p
    du[2] = u[2] * u[2] - p
    return nothing
end

prob = NonlinearProblem(f, u0, p)
@benchmark sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">18.945 μs</span></span> … <span class="sgr35">94.547 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">20.218 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">20.558 μs</span></span> ± <span class="sgr32"> 2.076 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

     ▁▆█<span class="sgr34">█</span>▅<span class="sgr32">▁</span>                                                    
  ▂▃▅███<span class="sgr34">█</span>█<span class="sgr32">█</span>▆▅▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▁▂▂▁▂▂▂▂▂▂▂▂▁▁▁▁▁▂▂▂▂▂▂▂▂▂▂▂▂ ▃
  18.9 μs<span class="sgr90">         Histogram: frequency by time</span>          31 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">11.38 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">154</span>.</code></pre><p>Notice how much faster this already runs! We can make this code even simpler by using the <code>.=</code> in-place broadcasting.</p><pre><code class="language-julia hljs">function f(du, u, p)
    du .= u .* u .- p
    return nothing
end

@benchmark sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">18.875 μs</span></span> … <span class="sgr35">128.780 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">20.037 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">20.415 μs</span></span> ± <span class="sgr32">  2.395 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

     ▄▇█<span class="sgr34">▆</span>▂<span class="sgr32"> </span>                                                     
  ▂▃▇███<span class="sgr34">█</span>█<span class="sgr32">▇</span>▅▄▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▁▁▂▂▂▂▁▂▁▁▂▂▁▁▂▂▂▂▂▂▂▂▂▂▂▂ ▃
  18.9 μs<span class="sgr90">         Histogram: frequency by time</span>         30.9 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">11.38 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">154</span>.</code></pre><h2 id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><a class="docs-heading-anchor" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve">Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</a><a id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve" title="Permalink"></a></h2><p>Allocations are only expensive if they are “heap allocations”. For a more in-depth definition of heap allocations, <a href="http://net-informations.com/faq/net/stack-heap.htm">there are many sources online</a>. But a good working definition is that heap allocations are variable-sized slabs of memory which have to be pointed to, and this pointer indirection costs time. Additionally, the heap has to be managed, and the garbage controllers has to actively keep track of what&#39;s on the heap.</p><p>However, there&#39;s an alternative to heap allocations, known as stack allocations. The stack is statically-sized (known at compile time) and thus its accesses are quick. Additionally, the exact block of memory is known in advance by the compiler, and thus re-using the memory is cheap. This means that allocating on the stack has essentially no cost!</p><p>Arrays have to be heap allocated because their size (and thus the amount of memory they take up) is determined at runtime. But there are structures in Julia which are stack-allocated. <code>struct</code>s for example are stack-allocated “value-type”s. <code>Tuple</code>s are a stack-allocated collection. The most useful data structure for NonlinearSolve though is the <code>StaticArray</code> from the package <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. These arrays have their length determined at compile-time. They are created using macros attached to normal array expressions, for example:</p><pre><code class="language-julia hljs">using StaticArrays

A = SA[2.0, 3.0, 5.0]
typeof(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SVector{3, Float64}<span class="sgr90"> (alias for StaticArraysCore.SArray{Tuple{3}, Float64, 1, 3})</span></code></pre><p>Notice that the <code>3</code> after <code>SVector</code> gives the size of the <code>SVector</code>. It cannot be changed. Additionally, <code>SVector</code>s are immutable, so we have to create a new <code>SVector</code> to change values. But remember, we don&#39;t have to worry about allocations because this data structure is stack-allocated. <code>SArray</code>s have numerous extra optimizations as well: they have fast matrix multiplication, fast QR factorizations, etc. which directly make use of the information about the size of the array. Thus, when possible, they should be used.</p><p>Unfortunately, static arrays can only be used for sufficiently small arrays. After a certain size, they are forced to heap allocate after some instructions and their compile time balloons. Thus, static arrays shouldn&#39;t be used if your system has more than ~20 variables. Additionally, only the native Julia algorithms can fully utilize static arrays.</p><p>Let&#39;s ***optimize our nonlinear solve using static arrays***. Note that in this case, we want to use the out-of-place allocating form, but this time we want to output a static array. Doing it with broadcasting looks like:</p><pre><code class="language-julia hljs">f_SA(u, p) = u .* u .- p

u0 = SA[1.0, 1.0]
p = 2.0
prob = NonlinearProblem(f_SA, u0, p)

@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">11.822 μs</span></span> … <span class="sgr35">87.964 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">12.583 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">12.772 μs</span></span> ± <span class="sgr32"> 1.442 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▆██<span class="sgr34">▅</span><span class="sgr32">▁</span>                                                      
  ▂▆███<span class="sgr34">█</span><span class="sgr32">█</span>▇▄▄▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▂▁▂▁▁▁▁▁▁▂▂▂▁▁▁▁▁▁▁▁▂▁▁▁▁▁▁▁▂▂▂ ▃
  11.8 μs<span class="sgr90">         Histogram: frequency by time</span>        21.8 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">9.30 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">116</span>.</code></pre><p>Note that only change here is that <code>u0</code> is made into a StaticArray! If we needed to write <code>f</code> out for a more complex nonlinear case, then we&#39;d simply do the following:</p><pre><code class="language-julia hljs">f_SA(u, p) = SA[u[1] * u[1] - p, u[2] * u[2] - p]

@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">11.672 μs</span></span> … <span class="sgr35">78.476 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">12.433 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">12.648 μs</span></span> ± <span class="sgr32"> 1.446 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▄█<span class="sgr34">▇</span>▅<span class="sgr32">▁</span>                                                      
  ▂▆██<span class="sgr34">█</span>█<span class="sgr32">█</span>▆▄▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▂▂▁▂▁▂▁▁▁▁▁▂▁▁▁▁▂▁▂▂▁▂▂▂▂ ▃
  11.7 μs<span class="sgr90">         Histogram: frequency by time</span>        21.7 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">9.30 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">116</span>.</code></pre><p>However, notice that this did not give us a speedup but rather a slowdown. This is because many of the methods in NonlinearSolve.jl are designed to scale to larger problems, and thus aggressively do things like caching which is good for large problems but not good for these smaller problems and static arrays. In order to see the full benefit, we need to move to one of the methods from SimpleNonlinearSolve.jl which are designed for these small-scale static examples. Let&#39;s now use <code>SimpleNewtonRaphson</code>:</p><pre><code class="language-julia hljs">@benchmark solve(prob, SimpleNewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 99 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">788.545 ns</span></span> … <span class="sgr35"> 2.038 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">793.101 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">803.032 ns</span></span> ± <span class="sgr32">37.659 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▇█<span class="sgr34">▇</span>▄▂▁<span class="sgr32"> </span>                     ▁▂▃▂▁                            ▂
  ██<span class="sgr34">█</span>███<span class="sgr32">▇</span>▇█▇▇▆▆▆▆▅▅▅▃▅▄▄▄▄▄▃▄▅█████▇▇▅▇▅▇▆▆▅▅▅▂▂▃▅▂▃▃▂▄▄▄▄▂▄▄▅ █
  789 ns<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       947 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">80 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1</span>.</code></pre><p>And there we go, around <code>40ns</code> from our starting point of almost <code>4μs</code>!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started with Nonlinear Rootfinding in Julia</a><a class="docs-footer-nextpage" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 27 September 2024 19:49">Friday 27 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

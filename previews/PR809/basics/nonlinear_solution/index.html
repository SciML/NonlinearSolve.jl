<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Solutions · NonlinearSolve.jl</title><meta name="title" content="Nonlinear Solutions · NonlinearSolve.jl"/><meta property="og:title" content="Nonlinear Solutions · NonlinearSolve.jl"/><meta property="twitter:title" content="Nonlinear Solutions · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/basics/nonlinear_solution/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/basics/nonlinear_solution/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/basics/nonlinear_solution/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li><li><a class="tocitem" href="../../tutorials/nonlinear_solve_gpus/">Accelerated Rootfinding on GPUs</a></li><li><a class="tocitem" href="../../tutorials/snes_ex2/">PETSc SNES Example 2</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Solutions</a><ul class="internal"><li><a class="tocitem" href="#Statistics"><span>Statistics</span></a></li><li><a class="tocitem" href="#Return-Code"><span>Return Code</span></a></li></ul></li><li><a class="tocitem" href="../autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../verbosity/">Controlling Solver Verbosity</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li><a class="tocitem" href="../../native/solvers/">NonlinearSolve.jl Solvers</a></li><li><a class="tocitem" href="../../native/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/bracketingnonlinearsolve/">BracketingNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../native/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../native/descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../../native/globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../../native/diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/petsc/">PETSc.jl</a></li><li><a class="tocitem" href="../../api/scipy/">SciPy</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/homotopycontinuation/">HomotopyContinuation.jl</a></li></ul></li><li><span class="tocitem">Sub-Packages</span><ul><li><a class="tocitem" href="../../api/SciMLJacobianOperators/">SciMLJacobianOperators.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Nonlinear Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/basics/nonlinear_solution.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="solution"><a class="docs-heading-anchor" href="#solution">Nonlinear Solutions</a><a id="solution-1"></a><a class="docs-heading-anchor-permalink" href="#solution" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SciMLBase.AbstractNonlinearSolution"><a class="docstring-binding" href="#SciMLBase.AbstractNonlinearSolution"><code>SciMLBase.AbstractNonlinearSolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractNonlinearSolution{T, N} &lt;: SciMLBase.AbstractNoTimeSolution{T, N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/SciMLBase.jl#L593">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.NonlinearSolution"><a class="docstring-binding" href="#SciMLBase.NonlinearSolution"><code>SciMLBase.NonlinearSolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NonlinearSolution{T, N, uType, R, P, A, O, uType2, S, Tr} &lt;: SciMLBase.AbstractNonlinearSolution{T, N}</code></pre><p>Representation of the solution to a nonlinear equation defined by a NonlinearProblem, or the steady state solution to a differential equation defined by a SteadyStateProblem.</p><p><strong>Fields</strong></p><ul><li><code>u</code>: the representation of the nonlinear equation&#39;s solution.</li><li><code>resid</code>: the residual of the solution.</li><li><code>prob</code>: the original NonlinearProblem/SteadyStateProblem that was solved.</li><li><code>alg</code>: the algorithm type used by the solver.</li><li><code>original</code>: if the solver is wrapped from an alternative solver ecosystem, such as NLsolve.jl, then this is the original return from said solver library.</li><li><code>retcode</code>: the return code from the solver. Used to determine whether the solver solved successfully or whether it exited due to an error. For more details, see <a href="https://docs.sciml.ai/SciMLBase/stable/interfaces/Solutions/#retcodes">the return code documentation</a>.</li><li><code>left</code>: if the solver is bracketing method, this is the final left bracket value.</li><li><code>right</code>: if the solver is bracketing method, this is the final right bracket value.</li><li><code>stats</code>: statistics of the solver, such as the number of function evaluations required.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/solutions/nonlinear_solutions.jl#L37">source</a></section></details></article><h2 id="Statistics"><a class="docs-heading-anchor" href="#Statistics">Statistics</a><a id="Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SciMLBase.NLStats"><a class="docstring-binding" href="#SciMLBase.NLStats"><code>SciMLBase.NLStats</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct NLStats</code></pre><p>Statistics from the nonlinear equation solver about the solution process.</p><p><strong>Fields</strong></p><ul><li><code>nf</code>: Number of function evaluations.</li><li><code>njacs</code>: Number of Jacobians created during the solve.</li><li><code>nfactors</code>: Number of factorzations of the jacobian required for the solve.</li><li><code>nsolve</code>: Number of linear solves <code>W\b</code> required for the solve.</li><li><code>nsteps</code>: Total number of iterations for the nonlinear solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/solutions/nonlinear_solutions.jl#L1">source</a></section></details></article><h2 id="Return-Code"><a class="docs-heading-anchor" href="#Return-Code">Return Code</a><a id="Return-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Code" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Default"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Default"><code>SciMLBase.ReturnCode.Default</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Default</code></pre><p>The default state of the solver. If this return code is given, then the solving process is either still in process or the solver library has not been setup with the return code interface and thus the return code is undetermined.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>A common reason for <code>Default</code> return codes is that a solver is a non-SciML solver which does not fully conform to the interface. Please open an issue if this is seen and it will be improved.</li><li>Another common reason for a <code>Default</code> return code is if the solver is probed internally before the solving process is done, such as through the callback interface. Return codes are set to <code>Default</code> to start and are changed to <code>Success</code> and other return codes upon finishing the solving process or hitting a numerical difficulty.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L33-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Success"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Success"><code>SciMLBase.ReturnCode.Success</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Success</code></pre><p>The success state of the solver. If this return code is given, then the solving process was successful, but no extra information about that success is given.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>This is the most common return code and most solvers will give this return code if the solving process went as expected without any errors or detected numerical issues.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L56-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.StalledSuccess"><a class="docstring-binding" href="#SciMLBase.ReturnCode.StalledSuccess"><code>SciMLBase.ReturnCode.StalledSuccess</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>ReturnCode.StalledSuccess</p><p>The solution process has stalled, but the stall is not considered a failure of the solver. For example, a nonlinear optimizer may have stalled, that is its steps went to zero, which is a valid local minima.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>For nonlinear least squares optimizations, this is given for local minima which exceed the chosen tolerance, i.e. <code>f(x)=resid</code> where <code>||resid||&gt;tol</code> so it&#39;s not considered ReturnCode.Success but it is still considered a successful return of the solver since it&#39;s a valid local minima (and there no minima which achieves the tolerance).</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L404-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.ExactSolutionLeft"><a class="docstring-binding" href="#SciMLBase.ReturnCode.ExactSolutionLeft"><code>SciMLBase.ReturnCode.ExactSolutionLeft</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.ExactSolutionLeft</code></pre><p>The success state of the solver. If this return code is given, then the solving process was successful, and the left solution was given.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for this return code is via a bracketing nonlinear solver, such as bisection, iterating to convergence is unable to give the exact <code>f(x)=0</code> solution due to floating point precision issues, and thus it gives the first floating point value to the left for <code>x</code>.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L287-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.ExactSolutionRight"><a class="docstring-binding" href="#SciMLBase.ReturnCode.ExactSolutionRight"><code>SciMLBase.ReturnCode.ExactSolutionRight</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.ExactSolutionRight</code></pre><p>The success state of the solver. If this return code is given, then the solving process was successful, and the right solution was given.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for this return code is via a bracketing nonlinear solver, such as bisection, iterating to convergence is unable to give the exact <code>f(x)=0</code> solution due to floating point precision issues, and thus it gives the first floating point value to the right for <code>x</code>.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L306-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.FloatingPointLimit"><a class="docstring-binding" href="#SciMLBase.ReturnCode.FloatingPointLimit"><code>SciMLBase.ReturnCode.FloatingPointLimit</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.FloatingPointLimit</code></pre><p>The success state of the solver. If this return code is given, then the solving process was successful, and the closest floating point value to the solution was given.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for this return code is via a nonlinear solver, such as Falsi, iterating to convergence is unable to give the exact <code>f(x)=0</code> solution due to floating point precision issues, and thus it gives the closest floating point value to the true solution for <code>x</code>.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L325-L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Terminated"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Terminated"><code>SciMLBase.ReturnCode.Terminated</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Terminated</code></pre><p>The successful termination state of the solver. If this return code is given, then the solving process was successful at terminating the solve, usually through a callback <code>affect!</code> via <code>terminate!(integrator)</code>.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is if a user calls a callback which uses <code>terminate!(integrator)</code> to halt the integration at a user-chosen stopping point.</li><li>Another common reason for this return code is due to implicit <code>terminate!</code> statements in some library callbacks. For example, <code>SteadyStateCallback</code> uses <code>terminate!</code> internally, so solutions which reach steady state will have a <code>ReturnCode.Terminated</code> state instead of a <code>ReturnCode.Success</code> state. Similarly, problems solved via SteadyStateDiffEq.jl will have this <code>ReturnCode.Terminated</code> state if a timestepping method is used to solve to steady state.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L73-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.ConvergenceFailure"><a class="docstring-binding" href="#SciMLBase.ReturnCode.ConvergenceFailure"><code>SciMLBase.ReturnCode.ConvergenceFailure</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.ConvergenceFailure</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful because internal nonlinear solver iterations failed to converge.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because an inappropriate nonlinear solver was chosen. If fixed point iteration is used on a stiff problem, it will be faster by avoiding the Jacobian but it will make a stiff ODE solver not stable for stiff problems!</li><li>For nonlinear solvers, this can occur if certain threshold was exceeded. For example, in approximate jacobian solvers like Broyden, Klement, etc. if the number of jacobian resets exceeds the threshold, then this return code is given.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L246-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.InitialFailure"><a class="docstring-binding" href="#SciMLBase.ReturnCode.InitialFailure"><code>SciMLBase.ReturnCode.InitialFailure</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.InitialFailure</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful because the initialization process failed.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because the initialization process of a DAE solver failed to find consistent initial conditions, which can occur if the differentiation index of the DAE solver is too high. Most DAE solvers only allow for index-1 DAEs, and so an index-2 DAE will fail during this initialization. To solve this kind of problem, use <code>ModelingToolkit.jl</code> and its <code>structural_simplify</code> method to reduce the index of the DAE.</li><li>Another common reason for this return code is if the initial condition was not suitable for the numerical solve. For example, the initial point had a <code>NaN</code> or <code>Inf</code>. Or in optimization, this can occur if the initial point is outside of the bound constraints given by the user.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L221-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Unstable"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Unstable"><code>SciMLBase.ReturnCode.Unstable</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Unstable</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because the <code>unstable_check</code> function, as given by the <code>unstable_check</code> common keyword argument (or its default), give a <code>true</code> at the current state.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because <code>u</code> contains a <code>NaN</code> or <code>Inf</code> value. The default <code>unstable_check</code> only checks for these values.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L202-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.MaxIters"><a class="docstring-binding" href="#SciMLBase.ReturnCode.MaxIters"><code>SciMLBase.ReturnCode.MaxIters</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.MaxIters</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because the solver&#39;s iterations hit the <code>maxiters</code> either set by default or by the user in the <code>solve</code>/<code>init</code> command.</p><p><strong>Note about Nonlinear Optimization</strong></p><p>In nonlinear optimization, many solvers (such as <code>OptimizationOptimisers.Adam</code>) do not have an exit criteria other than <code>iters == maxiters</code>. In this case, the solvers will iterate until <code>maxiters</code> and exit with a <code>Success</code> return code, as that is a successful run of the solver and not considered to be an error state. Solves with early termination criteria, such as <code>Optim.BFGS</code> exiting when the gradient is sufficiently close to zero, will give <code>ReturnCode.MaxIters</code> on exits which require the maximum iteration.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>This commonly occurs in ODE solving if a non-stiff method (e.g. <code>Tsit5</code>) is used in an algorithm choice for a stiff ODE. It is recommended that in such cases, one tries a stiff ODE solver.</li><li>This commonly occurs in optimization and nonlinear solvers if the tolerance on <code>solve</code> to too low and cannot be achieved due to floating point error or the condition number of the solver matrix. Double check that the chosen tolerance is numerically possible.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L120-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.MaxTime"><a class="docstring-binding" href="#SciMLBase.ReturnCode.MaxTime"><code>SciMLBase.ReturnCode.MaxTime</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.MaxTime</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because the solver&#39;s timer hit <code>maxtime</code> either set by default or by the user in the <code>solve</code>/<code>init</code> command.</p><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L355-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.MaxNumSub"><a class="docstring-binding" href="#SciMLBase.ReturnCode.MaxNumSub"><code>SciMLBase.ReturnCode.MaxNumSub</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.MaxNumSub</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because during the solver&#39;s adaptivity, mesh length exceeded the <code>max_num_subintervals</code> either set by default or specified by users in the solver.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>This commonly occurs in BVP solving if the original mesh are too coarse or the tolerance are too stringent. It is recommended that in such cases, one tries to increase the default <code>max_num_subintervals</code> in solvers, or decrease the tolerance.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L152-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Failure"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Failure"><code>SciMLBase.ReturnCode.Failure</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Failure</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful but no extra information is given.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because the solver is a wrapped solver (i.e. a Fortran code) which does not provide any extra information about its exit state. If this is from a Julia-based solver, please open an issue.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L269-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.InternalLineSearchFailed"><a class="docstring-binding" href="#SciMLBase.ReturnCode.InternalLineSearchFailed"><code>SciMLBase.ReturnCode.InternalLineSearchFailed</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.InternalLineSearchFailed</code></pre><p>Internal Line Search used by the algorithm has failed.</p><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L369-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.InternalLinearSolveFailed"><a class="docstring-binding" href="#SciMLBase.ReturnCode.InternalLinearSolveFailed"><code>SciMLBase.ReturnCode.InternalLinearSolveFailed</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.InternalLinearSolveFailed</code></pre><p>The linear problem inside another problem (for example inside a NonlinearProblem) could not be solved.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>If a rank-deficient matrix originated inside the nonlinear solve and the provided linear solver is incapable of handling those cases.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L424-L438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Stalled"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Stalled"><code>SciMLBase.ReturnCode.Stalled</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Stalled</code></pre><p>The solution has stalled. This is only returned by algorithms for which stalling is a failure mode, such as on a NonlinearProblem where the found solution is larger than the accepted tolerance.</p><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L391-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.ShrinkThresholdExceeded"><a class="docstring-binding" href="#SciMLBase.ReturnCode.ShrinkThresholdExceeded"><code>SciMLBase.ReturnCode.ShrinkThresholdExceeded</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.ShrinkThresholdExceeded</code></pre><p>The trust region radius was shrunk more times than the provided threshold.</p><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L380-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.Infeasible"><a class="docstring-binding" href="#SciMLBase.ReturnCode.Infeasible"><code>SciMLBase.ReturnCode.Infeasible</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.Infeasible</code></pre><p>The optimization problem was proven to be infeasible by the solver.</p><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L344-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.DtNaN"><a class="docstring-binding" href="#SciMLBase.ReturnCode.DtNaN"><code>SciMLBase.ReturnCode.DtNaN</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.DtNaN</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because the <code>dt</code> of the integration was determined to be <code>NaN</code> and thus the solver could not continue.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because the automatic <code>dt</code> selection algorithm is used but the starting derivative has a <code>NaN</code> or <code>Inf</code> derivative term. Double check that the <code>f(u0,p,t0)</code> term is well-defined without <code>NaN</code> or <code>Inf</code> values.</li><li>Another common reason for this return code is because of a user set <code>dt</code> which is calculated to be a <code>NaN</code>. If <code>solve(prob,alg,dt=x)</code>, double check that <code>x</code> is not <code>NaN</code>.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L97-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ReturnCode.DtLessThanMin"><a class="docstring-binding" href="#SciMLBase.ReturnCode.DtLessThanMin"><code>SciMLBase.ReturnCode.DtLessThanMin</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ReturnCode.DtLessThanMin</code></pre><p>A failure exit state of the solver. If this return code is given, then the solving process was unsuccessful and exited early because the <code>dt</code> of the integration was made to be less than <code>dtmin</code>, i.e. <code>dt &lt; dtmin</code>.</p><p><strong>Common Reasons for Seeing this Return Code</strong></p><ul><li>The most common reason for seeing this return code is because the integration is going unstable. As <code>f(u,p,t) -&gt; infinity</code>, the time steps required by the solver to accurately handle the dynamics decreases. When it gets sufficiently small, <code>dtmin</code>, an exit is thrown as the solution is likely unstable. <code>dtmin</code> is also chosen to be around the value where floating point issues cause <code>t + dt == t</code>, and thus a <code>dt</code> of that size is impossible at floating point precision.</li><li>Another common reason for this return code is if domain constraints are set, such as by using <code>isoutofdomain</code>, but the domain constraint is incorrect. For example, if one is solving the ODE <code>f(u,p,t) = -u - 1</code>, one may think &quot;but I want a solution with <code>u &gt; 0</code> and thus I will set <code>isoutofdomain(u,p,t) = u &lt; 0</code>. However, the true solution of this ODE is not positive, and thus what will occur is that the solver will try to decrease <code>dt</code> until it can give an accurate solution that is positive. As this is impossible, it will continue to shrink the <code>dt</code> until <code>dt &lt; dtmin</code> and then exit with this return code.</li></ul><p><strong>Properties</strong></p><ul><li><code>successful_retcode</code> = <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.138.0/src/retcodes.jl#L172-L199">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solve/">« Common Solver Options (Solve Keyword Arguments)</a><a class="docs-footer-nextpage" href="../autodiff/">Automatic Differentiation Backends »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 08:07">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
